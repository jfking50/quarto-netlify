{
  "hash": "1cac97ee29dc2376dc7df188ebacfc80",
  "result": {
    "markdown": "---\ntitle: \"Wordament Solver\"\ndescription: \"Get help finding potential Wordament words.\"\nauthor: \"John King\"\ndate: \"4/8/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: false\n    code-tools: true\n    code-copy: true\n    df-print: paged\nexecute: \n  warning: false\n  message: false\n  echo: true\ncategories:\n  - R\nimage: \"teaser.jpg\"\n---\n\n\nSometimes in Microsoft Wordament daily challenges, there's an awkwardly placed letter the game seems to pick on relentlessly `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM192 368H320c8.8 0 16 7.2 16 16s-7.2 16-16 16H192c-8.8 0-16-7.2-16-16s7.2-16 16-16zm32-144c0 35.3-28.7 64-64 64s-64-28.7-64-64c0-26 15.5-48.4 37.8-58.4c-3.7 5.2-5.8 11.6-5.8 18.4c0 17.7 14.3 32 32 32s32-14.3 32-32c0-6.9-2.2-13.2-5.8-18.4C208.5 175.6 224 198 224 224zm128 64c-35.3 0-64-28.7-64-64c0-26 15.5-48.4 37.8-58.4c-3.7 5.2-5.8 11.6-5.8 18.4c0 17.7 14.3 32 32 32s32-14.3 32-32c0-6.9-2.2-13.2-5.8-18.4C400.5 175.6 416 198 416 224c0 35.3-28.7 64-64 64z\"/></svg>`{=html}. For situations like this, some word suggestions would be nice. I don't have the official dictionary of valid Wordament words, so I'll just have to get a reasonably large English word list. My algorithm isn't going to accommodate board tiles that are prefixes, suffixes, or either-or tiles like b/u because it adds a fair amount of complexity to the code, and those kinds of tiles are almost never problematic.\n\n## Board Setup\n\nFirst, though, I'll consider the 4x4 game board as just a vector of characters from left to right and top to bottom, just like you'd read a book. Therefore, the board (and vector) will have the the following indices:\n\n|     |     |     |     |\n|:---:|:---:|:---:|:---:|\n|  1  |  2  |  3  |  4  |\n|  5  |  6  |  7  |  8  |\n|  9  | 10  | 11  | 12  |\n| 13  | 14  | 15  | 16  |\n\nAn example board is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboard <- \n  c(\"s\", \"i\", \"r\", \"s\",\n    \"e\", \"t\", \"a\", \"c\",\n    \"h\", \"l\", \"e\", \"m\", \n    \"s\", \"u\", \"o\", \"s\")\n```\n:::\n\n\nUsing the same indexing scheme, I create an adjacency list. The first item in the list is a vector of the board tiles that are adjacent to index 1. The second item in the list are the tiles adjacent to index 2, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj <- list(\n  c(2,5,6),\n  c(1,3,5,6,7),\n  c(2,4,6,7,8),\n  c(3,7,8),\n  c(1,2,6,9,10),\n  c(1,2,3,5,7,9,10,11),\n  c(2,3,4,6,8,10,11,12),\n  c(3,4,7,11,12),\n  c(5,6,10,13,14),\n  c(5,6,7,9,11,13,14,15),\n  c(6,7,8,10,12,14,15,16),\n  c(7,8,11,15,16),\n  c(9,10,14),\n  c(9,10,11,13,15),\n  c(10,11,12,14,16),\n  c(11,12,15)\n  )\n\nadj[[1]] # tiles adjacent to tile 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5 6\n```\n:::\n:::\n\n\n## Create Valid Sequences\n\nThe first way I thought of to tackle this problem is to generate all valid two-tile sequences using the above adjacency list. Once I have valid two-tile sequences, I can use those to generate valid three-tile sequences, and so on. I begin with index 1 from the adjacency list, which tells me that valid two-tile combinations for tile 1 are 1-2, 1-5, and 1-6. I put all of those in a two column matrix where column 1 is the first tile in the sequence, and column 2 is the second tile. I convert that 3x2 matrix into a dataframe so I can row bind it with the dataframe for tile 2, then tile 3, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(purrr)\n\ns2 <- \n  seq_along(adj) %>%\n  map_dfr(~as.data.frame(\n                   matrix(\n                     c(rep(.x, length(adj[[.x]])), adj[[.x]]), \n                     byrow=FALSE, ncol = 2)\n                 )\n  )\n\nhead(s2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"V1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"2\",\"_rn_\":\"1\"},{\"1\":\"1\",\"2\":\"5\",\"_rn_\":\"2\"},{\"1\":\"1\",\"2\":\"6\",\"_rn_\":\"3\"},{\"1\":\"2\",\"2\":\"1\",\"_rn_\":\"4\"},{\"1\":\"2\",\"2\":\"3\",\"_rn_\":\"5\"},{\"1\":\"2\",\"2\":\"5\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nThings get just a little more complicated for 3+ tile sequences, but it's the same process for each successively longer sequence, so I'll make a function `get_tiles()` to do it. For three-tile sequences, I'll iterate through each row of two-tile sequences, look up the last number in the sequence, get it's associated adjacency list, and remove tiles that have already been visited in the sequence. First the three-tiles sequences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_tiles <- \n  function(adj_list, prev_sequence){\n    1:nrow(prev_sequence) %>%\n      map_dfr(function(x){\n        # get the shorter input sequence\n        left_seq <- as.matrix(prev_sequence[x, ])\n        # get candidate adjacent tiles\n        adj_cand <- adj_list[[prev_sequence[x, ncol(prev_sequence)]]]\n        # remove tiles that have already been visited\n        adj_unique <- adj_cand[!adj_cand %in% left_seq]\n        # plop it in a dataframe\n        as.data.frame(\n          matrix(\n            c(rep(left_seq, each = length(adj_unique)), adj_unique), \n            byrow=FALSE, ncol = ncol(prev_sequence) + 1\n          )\n        )\n      })\n  }\n\ns3 <- get_tiles(adj, s2)\n\nhead(s3)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"V1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"_rn_\":\"1\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"5\",\"_rn_\":\"2\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"6\",\"_rn_\":\"3\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"7\",\"_rn_\":\"4\"},{\"1\":\"1\",\"2\":\"5\",\"3\":\"2\",\"_rn_\":\"5\"},{\"1\":\"1\",\"2\":\"5\",\"3\":\"6\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nAnd then four-tile sequences. I'm not going to go beyond that for this post because you get the idea by now `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M96 191.1H32c-17.67 0-32 14.33-32 31.1v223.1c0 17.67 14.33 31.1 32 31.1h64c17.67 0 32-14.33 32-31.1V223.1C128 206.3 113.7 191.1 96 191.1zM512 227c0-36.89-30.05-66.92-66.97-66.92h-99.86C354.7 135.1 360 113.5 360 100.8c0-33.8-26.2-68.78-70.06-68.78c-46.61 0-59.36 32.44-69.61 58.5c-31.66 80.5-60.33 66.39-60.33 93.47c0 12.84 10.36 23.99 24.02 23.99c5.256 0 10.55-1.721 14.97-5.26c76.76-61.37 57.97-122.7 90.95-122.7c16.08 0 22.06 12.75 22.06 20.79c0 7.404-7.594 39.55-25.55 71.59c-2.046 3.646-3.066 7.686-3.066 11.72c0 13.92 11.43 23.1 24 23.1h137.6C455.5 208.1 464 216.6 464 227c0 9.809-7.766 18.03-17.67 18.71c-12.66 .8593-22.36 11.4-22.36 23.94c0 15.47 11.39 15.95 11.39 28.91c0 25.37-35.03 12.34-35.03 42.15c0 11.22 6.392 13.03 6.392 22.25c0 22.66-29.77 13.76-29.77 40.64c0 4.515 1.11 5.961 1.11 9.456c0 10.45-8.516 18.95-18.97 18.95h-52.53c-25.62 0-51.02-8.466-71.5-23.81l-36.66-27.51c-4.315-3.245-9.37-4.811-14.38-4.811c-13.85 0-24.03 11.38-24.03 24.04c0 7.287 3.312 14.42 9.596 19.13l36.67 27.52C235 468.1 270.6 480 306.6 480h52.53c35.33 0 64.36-27.49 66.8-62.2c17.77-12.23 28.83-32.51 28.83-54.83c0-3.046-.2187-6.107-.6406-9.122c17.84-12.15 29.28-32.58 29.28-55.28c0-5.311-.6406-10.54-1.875-15.64C499.9 270.1 512 250.2 512 227z\"/></svg>`{=html}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns4 <- get_tiles(adj, s3)\n\nhead(s4)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"V1\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V2\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V3\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"V4\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"4\",\"_rn_\":\"1\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"6\",\"_rn_\":\"2\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"7\",\"_rn_\":\"3\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"8\",\"_rn_\":\"4\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"5\",\"4\":\"6\",\"_rn_\":\"5\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"5\",\"4\":\"9\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Load A Dictionary\n\nI downloaded an open source English language dictionary a few years ago for another project, but I don't remember where I got it from. It's a simple JSON file containing 370,101 words, and that's it. Here are the first eight words.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndict <- jsonlite::fromJSON(\"words_dictionary.json\") %>% names()\n\ndict[1:8]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"      \"aa\"     \"aaa\"    \"aah\"    \"aahed\"  \"aahing\" \"aahs\"   \"aal\"   \n```\n:::\n:::\n\n\nWhile we're at it, I'm curious about the distribution of word lengths. How many 3-letter words are there compared to 4-, and 5-, etc. letter words?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ntibble(Word = dict) %>%\n  mutate(Characters = nchar(Word)) %>%\n  group_by(Characters) %>%\n  tally %>%\n  ggplot() +\n  geom_col(aes(x=Characters, y=n)) +\n  theme_bw() +\n  xlim(1, 25) +\n  ylab(\"Count\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nInteresting! There are more 9-letter words than any other word length - I was guessing the most common word length was shorter.\n\n## Tile Coordinates\n\nUltimately, I want to be able to plot the game board and, for a valid word, overlay an arrow showing which tiles make up that word. That means I need to map each tile to an (x, y) coordinate pair. Tile 13 (an s) is in the lower left, so it will have an (x, y) coordinate of (1, 1). Tile 14 will be (2, 1), etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntile_coords <- expand.grid(1:4, 1:4)\ncolnames(tile_coords) <- c(\"x\", \"y\")\n\ntile_coords <- tile_coords %>%\n  mutate(tile = c(13, 14, 15, 16, 9, 10, 11, 12, 5, 6, 7, 8, 1, 2, 3, 4),\n         letter = c(board[13:16], board[9:12], board[5:8], board[1:4]))\n\nhead(tile_coords)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"tile\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"letter\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"1\",\"2\":\"1\",\"3\":\"13\",\"4\":\"s\",\"_rn_\":\"1\"},{\"1\":\"2\",\"2\":\"1\",\"3\":\"14\",\"4\":\"u\",\"_rn_\":\"2\"},{\"1\":\"3\",\"2\":\"1\",\"3\":\"15\",\"4\":\"o\",\"_rn_\":\"3\"},{\"1\":\"4\",\"2\":\"1\",\"3\":\"16\",\"4\":\"s\",\"_rn_\":\"4\"},{\"1\":\"1\",\"2\":\"2\",\"3\":\"9\",\"4\":\"h\",\"_rn_\":\"5\"},{\"1\":\"2\",\"2\":\"2\",\"3\":\"10\",\"4\":\"l\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Valid Words\n\nNow it;s time to put everything together. I have all of the possible tile sequences, and each sequence will generate a word. Not all of those words will be valid English words, in which case I'll drop that sequence. While I'm at it, need to keep track of tile coordinates for plotting later. Sounds simple enough, and my first approach involved some nested loops to iterate through tile sequences and tile coordinates. It worked, but it was way too slow once I got to 5-letter words, and it was only going to get worse with longer words since there are so many more of them. Instead of looping, I went with an approach of switching between wide and long data so that I could to column-wise operations, which is *much* faster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr) # for pivoting and unite\n\nget_valid_words <- function(df){\n  \n  df_new <- df %>% \n    # add a column to track like tile sequences\n    mutate(sequence = row_number()) %>%\n    # convert to long data\n    pivot_longer(-sequence, values_to = \"tile\") %>%\n    # for each tile, add the corresponding letter from the board\n    left_join(tile_coords %>% select(-x, -y), by = \"tile\") %>%\n    select(-tile) %>%\n    # convert back to wide data\n    pivot_wider(names_from = name, values_from = letter) %>%\n    # concatenate individual letters into a single word\n    unite(col = \"term\", -sequence, sep=\"\") %>% \n    # drop words not in the dictionary\n    filter(term %in% dict[nchar(dict)==ncol(df)]) %>%\n    # drop duplicate words\n    distinct(term, .keep_all = TRUE)\n  \n  df_new %>% \n    # add the tile sequence number\n    bind_cols(df[df_new %>% .$sequence, ]) %>%\n    select(-sequence) %>%\n    # convert to long data again\n    pivot_longer(-term, values_to = \"tile\") %>% \n    # attach tile coordinates to get line segments.\n    left_join(tile_coords %>% select(-letter), by = \"tile\")\n}\n\nvalid_4 <- get_valid_words(s4)\n\nhead(valid_4)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"term\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"name\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"tile\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"x\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"sirs\",\"2\":\"V1\",\"3\":\"1\",\"4\":\"1\",\"5\":\"4\"},{\"1\":\"sirs\",\"2\":\"V2\",\"3\":\"2\",\"4\":\"2\",\"5\":\"4\"},{\"1\":\"sirs\",\"2\":\"V3\",\"3\":\"3\",\"4\":\"3\",\"5\":\"4\"},{\"1\":\"sirs\",\"2\":\"V4\",\"3\":\"4\",\"4\":\"4\",\"5\":\"4\"},{\"1\":\"site\",\"2\":\"V1\",\"3\":\"1\",\"4\":\"1\",\"5\":\"4\"},{\"1\":\"site\",\"2\":\"V2\",\"3\":\"2\",\"4\":\"2\",\"5\":\"4\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow I have the data in the form needed for plotting: each valid word and coordinates for each tile/letter in the proper order.\n\n## Visualize\n\nHere's an initial stab at plotting one valid word \"mole\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_vline(xintercept = 0.5) +\n  geom_vline(xintercept = 1.5) +\n  geom_vline(xintercept = 2.5) +\n  geom_vline(xintercept = 3.5) +\n  geom_vline(xintercept = 4.5) +\n  geom_hline(yintercept = 0.5) +\n  geom_hline(yintercept = 1.5) +\n  geom_hline(yintercept = 2.5) +\n  geom_hline(yintercept = 3.5) +\n  geom_hline(yintercept = 4.5) +\n  coord_fixed() +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  geom_point(data = valid_4 %>% filter(term==\"mole\") %>% slice(1), \n             aes(x=x, y=y), \n             alpha = 0.25, size = 5) +\n  geom_path(data = valid_4 %>% filter(term==\"mole\"), \n            aes(x=x, y=y, group=term), \n            arrow = arrow(type = \"closed\"), color = \"gray\", linewidth = 2) +\n  geom_text(data = tile_coords, \n            aes(x=x, y=y, label=toupper(letter)), \n            color=\"red\", size= 12) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNow that I have the basic functionality worked out, I can leverage all this in a Shiny app so that a user can input whatever board letters they need help with.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}