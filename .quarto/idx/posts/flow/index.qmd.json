{"title":"Flow Fields","markdown":{"yaml":{"title":"Flow Fields","description":"Manual and algorithm-based methods for generating flow fields.","author":"John King","date":"5/26/2022","format":{"html":{"toc":true,"code-fold":true,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"message":false,"echo":true},"categories":["R","ggplot2","generative art"],"image":"teaser.png"},"headingText":"Manual Flow Fields","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, dpi=300)\n```\n\nIn this post, I'll generate art based on the idea of a material flowing through an area. Again this was inspired by the [the aRtsy package](https://github.com/koenderks/aRtsy), which has a `canvas_flow()` function to create such art. However, I like to learn how these generative functions work, so I attempt to write my own function. In the `canfav_flow()` description, it mentions [a post by Tyler Hobbs](https://tylerxhobbs.com/essays/2020/flow-fields) as a good reference. It does a nice job of walking through the concepts using pseudo code, which I'll implement in R. For motivation, here's an image from Tyler's post that will give you an idea of what I'm trying to create.\n\n![Image from Tyler Hobb's post (link above).](https://images.squarespace-cdn.com/content/v1/5c12933f365f02733c923e4e/1580788110303-VLBVW9I9EHKF4APSFZUK/long-curves.jpg?format=1500w)\n\n\nTyler Hobbs' post starts here, and I found it useful to understand the basics. First, I'll start with a 20x20 matrix, and define the flow as being in the same direction uniformly through the canvas. It helped me to visualize that by plotting a dot for every matrix cell with a line segment extending from the dot that indicates the direction of flow. For a uniform field, I populate the matrix with angles equal to $1\\frac{5}{8}\\pi$.\n\n```{r}\nm <- matrix((13/8)*pi, nrow=20, ncol=20)\n```\n\nThen, since I'm going to create the plot a few times, I'll write a function `get_plot()` that takes the matrix as an argument, and returns the plot I described. First, the necessary libraries.\n\n```{r message=FALSE, warning=FALSE}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\n\ntheme_set(theme_bw())\n\nget_plot <- function(M) {\n  as_tibble(M) %>% \n    pivot_longer(everything(), values_to='a') %>% \n    bind_cols(expand.grid(x=1:ncol(M), y=rev(1:nrow(M)))) %>% \n    mutate(xend = x+cos(a)*0.5, yend = y+sin(a)*0.5) %>%\n    ggplot() + \n    geom_point(aes(x=x, y=y)) +\n    geom_segment(aes(x=x, xend=xend, y=y, yend=yend)) +\n    coord_fixed()\n}\n\nget_plot(m)\n```\n\nTo generate the art, I want to draw individual lines of varying length through the field. The direction each line travels will be determined by the direction specified by the closest dot. Drawing lines through this field wouldn't be very interesting, so I'll add some curvature to it.\n\n```{r}\nfor (i in 1:ncol(m)){m[, i] <- m[, i] + i/20 * pi*(3/4)}\n\np <- get_plot(m)\np\n```\n\nSince I'll generate lines through flow fields multiple times in this post, The function `get_lines()` takes the flow matrix `m` as an argument, and also a multiplier `segment_length` for how long I want the line segments to be and `num_lines` for how many lines I want to generate. I create a data frame `df` to store the x and y coordinates of the lines. The initial `x` and `y` values are random numbers somewhere within the bounds of the flow matrix. The variable `theta` contains the value from the flow matrix (an angle) that is closest to the x and y coordinate. A new `x` and `y` are then calculated based on `theta` and these values are added to the data frame. Comments in the code provide the rest of the details.\n\n```{r}\nget_lines <- function(M = NULL, segment_length=5, num_lines=400){\n  for (j in 1:num_lines){\n    dims <- nrow(M)\n    # the actual line segment length \n    seg_len <- sample(dims:dims*segment_length, 1)\n    \n    df <- data.frame(x=rep(0, seg_len), y=rep(0, seg_len), seg = rep(0, seg_len))\n    \n    for (i in 1:seg_len){\n      if (i == 1){\n        x <- runif(1, 1, dims-1) # random starting value for x\n        y <- runif(1, 1, dims-1) # random starting value for y\n        df[i, ] <- c(x, y, j)\n      } else {\n        theta <- M[round(y, 0), round(x, 0)+1] # find the closest angle to x & y\n        x <- x + cos(theta) * 0.1 # 0.1 controls how far apart the new x & y \n        y <- y + sin(theta) * 0.1 # are from the previous values\n        if (x > dims - 1 | x < 1) break  # prevents lines going out of bounds\n        if (y > dims | y < 1) break\n        df[i, ] <- c(x, y, j)\n      }\n    }\n    df <- df %>% filter(seg != 0) # get rid of empty rows if lise was out of bounds\n    ifelse(j==1, df_new <- df, df_new <- df_new %>% bind_rows(df))\n  }\n  df_new\n}\n```\n\nFor generating one line, I'll choose an arbitrarily long line segment to make sure the function doesn't return a really short line.\n\n```{r}\nset.seed(4)\n\ndf <- get_lines(m, 50, 1)\n\nhead(df)\n```\n\nPlotting is straight forward. I'll just add the line to the previous plot `p`.\n\n```{r}\np +\n  geom_path(data=df, aes(x=x, y=y, group=seg), \n            color=\"red\", size=1, lineend=\"round\", linejoin=\"bevel\") +\n  theme(legend.position=\"none\") \n```\n\nPlotting several lines of varying length, I get:\n\n```{r}\nset.seed(4)\n\ndf <- get_lines(m, 5, 10)\n\np +\n  geom_path(data=df, aes(x=x, y=y, group=seg), \n            color=\"red\", size=1, lineend=\"round\", linejoin=\"bevel\") +\n  theme(legend.position=\"none\") \n```\n\n## Algorithm-Based Flow Fields\n\nTo make more visually interesting flow fields like Tyler's at the beginning of this post, I first tried to continue to manipulate the flow field above by adding different amounts of curvature to different part of the field. I had a difficult time controlling it so that I didn't have divergent areas and eventually gave up on that approach. Tyler stated that initializing the matrix with \"Perlin noise\" was common and provided pseudo code for how to do it. Unfortunately, the pseudo code didn't actually demonstrate how generate Perlin noise from scratch, rather it referred to a hypothetical function to generate the noise and then the pseudo code further manipulated those results. Buggers.\n\nThe [Wikipedia article](https://en.wikipedia.org/wiki/Perlin_noise) on Perlin noise stated that the algorithm\n\n> ...typically involves three steps: defining a grid of random gradient vectors, computing the dot product between the gradient vectors and their offsets, and interpolation between these values.\n\nAnd then provided about a page and a half of pseudo code to describe it. I wasn't motivated enough to redo that in R, but at least the site showed some visualizations for what it looked like. Here's one example.\n\n![Wikipedia image of Perlin noise.](https://upload.wikimedia.org/wikipedia/commons/d/da/Perlin_noise.jpg)\n\nIt didn't take much Googling to find an R package that generates Perlin noise. The package `ambient` does the trick with an aptly named `noise_perlin()` function that couldn't be simpler to use. I'll get a 20x20 matrix and plot it with the `get_plot()` function.\n\n```{r message=FALSE, warning=FALSE}\nlibrary(ambient)\n\nm <- noise_perlin(c(20, 20))\n\nget_plot(m) + ggtitle(\"Perlin Noise\")\n```\n\nWell that's not very interesting. Recall that we're plotting these values as radians, and they just don't vary enough as is. Note the range in values.\n\n```{r}\nrange(m)\n```\n\nI'll rescale them to range between -pi/2 and pi/2 and re-plot the values.\n\n```{r}\nm2 <- scales::rescale(m, to=c(-pi/2, pi/2))\n\nget_plot(m2) + ggtitle(\"Perlin Noise Rescaled\")\n```\n\nThat's better. I'll increase the scale even more.\n\n```{r}\nm3 <- scales::rescale(m, to=c(-pi, pi))\n\nget_plot(m3)  + ggtitle(\"Perlin Noise Rescaled Even More\")\n```\n\nI'll create a figure like the one in Wikipedia to visualize the matrix values.\n\n```{r}\nreshape2::melt(m3) %>%\n  ggplot() +\n  geom_tile(aes(x=Var1, y=Var2, fill=value)) +\n  coord_fixed()\n```\n\nThat's underwhelming... We need a bigger matrix!\n\n```{r}\nm <- noise_perlin(c(400,400))\n\nreshape2::melt(m) %>%\n  ggplot() +\n  geom_tile(aes(x=Var1, y=Var2, fill=value)) +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\") \n```\n\nWe can pass different parameters to the `noise_perlin()` function to get different types of noise. For example:\n\n```{r}\nm1 <- noise_perlin(c(100,100), fractal='fbm') # the default\nm2 <- noise_perlin(c(100,100), fractal='billow')\nm3 <- noise_perlin(c(100,100), fractal='rigid-multi') \n\np1 <- reshape2::melt(m1) %>%\n  ggplot() +\n  geom_tile(aes(x=Var1, y=Var2, fill=value)) +\n  coord_fixed() +\n  theme_void() +\n  ggtitle(\"FBM\") +\n  theme(legend.position=\"none\", plot.title = element_text(hjust = 0.5))\n\np2 <- reshape2::melt(m2) %>%\n  ggplot() +\n  geom_tile(aes(x=Var1, y=Var2, fill=value)) +\n  coord_fixed() +\n  theme_void() +\n  ggtitle(\"Billow\") +\n  theme(legend.position=\"none\", plot.title = element_text(hjust = 0.5)) \n\np3 <- reshape2::melt(m3) %>%\n  ggplot() +\n  geom_tile(aes(x=Var1, y=Var2, fill=value)) +\n  coord_fixed() +\n  theme_void() +\n  ggtitle(\"Rigid-Multi\") +\n  theme(legend.position=\"none\", plot.title = element_text(hjust = 0.5)) \n\ngridExtra::grid.arrange(p1, p2, p3, nrow=1)\n```\n\nFrom these images, we can see that the choice in fractal will have a large impact on the resulting art. Speaking of which, time to make some!\n\n```{r}\nm <- noise_perlin(c(100,100))\nm <- scales::rescale(m, to=c(-pi/2, pi/2))\n\nget_lines(M=m, segment_length=5, num_lines=400)  %>%\n  ggplot() + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: FBM Fractal, pi/2 scale, 400 lines\")\n\n```\n\n```{r}\nm <- noise_perlin(c(100,100))\nm <- scales::rescale(m, to=c(-pi/2, pi/2))\n\nget_lines(M=m, segment_length=5, num_lines=400)  %>%\n  ggplot() + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: Same as previous image.\")\n```\n\n```{r}\nm <- noise_perlin(c(100,100), fractal='billow')\nm <- scales::rescale(m, to=c(-pi, pi))\n\nget_lines(M=m, segment_length=5, num_lines=800)  %>%\n  ggplot() + \n  geom_path(aes(x=x, y=y, group=seg, color=seg), \n            alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: Billow Fractal, pi scale, 800 lines\")\n```\n\n```{r}\nm <- noise_perlin(c(100,100), fractal='rigid-multi')\nm <- scales::rescale(m, to=c(-pi/4, pi/4))\n\nget_lines(M=m, segment_length=5, num_lines=800)  %>%\n  ggplot() + \n  geom_path(aes(x=x, y=y, group=seg, color=seg), \n            alpha=0.5, size=1, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: Rigid-Multi Fractal, pi/4 scale, 800 (thicker) lines\")\n```\n\n```{r}\nm <- noise_perlin(c(100,100))\nm <- scales::rescale(m, to=c(-pi, pi))\ndf <- get_lines(M=m, segment_length=5, num_lines=400)\n\nm <- noise_perlin(c(100,100))\nm <- scales::rescale(m, to=c(-pi, pi))\ndf2 <- get_lines(M=m, segment_length=5, num_lines=400)\n\nggplot() + \n  geom_path(data=df, aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  geom_path(data=df2, aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: 2xFBM Fractals, pi scale, 400 lines\")\n```\n\n```{r}\nggplot() + \n  geom_path(data=df, aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=1, \n            lineend=\"round\", linejoin=\"bevel\") +\n  geom_path(data=df2, aes(x=x, y=y, group=seg), \n            color=\"white\", size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Options: 2xFBM Fractals, White Lines Over Black\")\n```\n\nFrom what I've seen in other posts, this is just the tip of the iceberg of the type of generative art from flow fields. Here are a few ideas.\n\n1.  Place starting points for lines on a grid instead of randomly.\n2.  Place several starting points for lines together in a tight circle.\n3.  Place starting points on just one side of the canvas.\n4.  Change the color of lines as they increase in length.\n5.  Change the thickness of lines as they increase in length.\n\nTo try any of these, I'll either need to modify the `get_lines()` function or just forget about the function and just write some code. I think I'll just write some code.\n\n### Gridded Starting Lines\n\nFor the gridded example, I also made the length of the lines a constant. The grid itself is apparent in the image below, which might not be desirable.\n\n```{r}\nm <- noise_perlin(c(100,100))\nm <- scales::rescale(m, to=c(-pi/2, pi/2))\n\nsp <- expand.grid(y=seq(1, 99, length.out=20), x=seq(1, 99, length.out=20))\n\nfor (j in 1:nrow(sp)){\n  dims <- nrow(m)\n  # the actual line segment length \n  seg_len <- 300\n  \n  df <- data.frame(x=rep(0, seg_len), y=rep(0, seg_len), seg = rep(0, seg_len))\n  \n  for (i in 1:seg_len){\n    if (i == 1){\n      x <- sp[j, 'x']\n      y <- sp[j, 'y']\n      df[i, ] <- c(x, y, j)\n    } else {\n      theta <- m[round(y, 0), round(x, 0)+1] # find the closest angle to x & y\n      x <- x + cos(theta) * 0.1 # 0.1 controls how far apart the new x & y \n      y <- y + sin(theta) * 0.1 # are from the previous values\n      if (x > dims - 1 | x < 1) break  # prevents lines going out of bounds\n      if (y > dims | y < 1) break\n      df[i, ] <- c(x, y, j)\n    }\n  }\n  df <- df %>% filter(seg != 0) # get rid of empty rows if lise was out of bounds\n  ifelse(j==1, df_new <- df, df_new <- df_new %>% bind_rows(df))\n}\n\np1<- \n  ggplot(df_new) + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Gridded Starting Points\")\n\n# random starting lines for comparison\np2 <-\n  get_lines(M=m, segment_length=5, num_lines=400)  %>%\n  ggplot() + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Random Starting Points\")\n\ngridExtra::grid.arrange(p1, p2, nrow=1)\n```\n\n### Starting Points In A Circle\n\nI also added jitter to the starting points in an attempt to get rid of the grid effect in the previous image.\n\n```{r}\n# create points in a circle with radius 2\na <- runif(10) * 2 * pi\nr <- 2 * sqrt(runif(10))\natt <- data.frame(x = r*cos(a), y = r*sin(a))\n\nseg_len <- 300\n\nsp <- expand.grid(y=seq(2, 99, length.out=10), x=seq(2, 99, length.out=10))\nsp$x <- jitter(sp$x, amount=4)\nsp$y <- jitter(sp$y, amount=4)\nsp2 <- data.frame(x=rep(0, seg_len*nrow(att)), y=rep(0, seg_len*nrow(att)))\n\nfor (i in 1:nrow(sp)){\n  sp2[(i-1)*10 + 1:10, 'x'] <- sp[i, 'x'] + att[, 'x']\n  sp2[(i-1)*10 + 1:10, 'y'] <- sp[i, 'y'] + att[, 'y']\n}\n\nfor (j in 1:nrow(sp2)){\n  dims <- nrow(m)\n\n  df <- data.frame(x=rep(0, seg_len), \n                   y=rep(0, seg_len), \n                   seg = rep(0, seg_len))\n  \n  for (i in 1:seg_len){\n    if (i == 1){\n      x <- sp2[j, 'x']\n      y <- sp2[j, 'y']\n      df[i, ] <- c(x, y, j)\n    } else {\n      if (x > dims - 1 | x < 1) break  # prevents lines going out of bounds\n      if (y > dims | y < 1) break\n      theta <- m[round(y, 0), round(x, 0)+1] # find the closest angle to x & y\n      x <- x + cos(theta) * 0.1 # 0.1 controls how far apart the new x & y \n      y <- y + sin(theta) * 0.1 # are from the previous values\n\n      df[i, ] <- c(x, y, j)\n    }\n  }\n  df <- df %>% filter(seg != 0) # get rid of empty rows if line was out of bounds\n  ifelse(j==1, df_new <- df, df_new <- df_new %>% bind_rows(df))\n}\n\nggplot(df_new) + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=\"black\", alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  ggtitle(\"Starting Points In A Circle\")\n```\n\n### Starting Points On Just One Side And Color Gradient Along Lines\n\nI like the spectral color palette on a black background, so changing up several things in this plot.\n\n```{r}\nsp <- data.frame(x=rep(1, 200), y=seq(1, 99, length.out=100))\n\nfor (j in 1:nrow(sp)){\n  dims <- nrow(m)\n  # the actual line segment length \n  seg_len <- 600\n  \n  df <- data.frame(x=rep(0, seg_len), \n                   y=rep(0, seg_len), \n                   seg = rep(0, seg_len), \n                   step = rep(0, seg_len))\n  \n  for (i in 1:seg_len){\n    if (i == 1){\n      x <- sp[j, 'x']\n      y <- sp[j, 'y']\n      df[i, ] <- c(x, y, j, i)\n    } else {\n      theta <- m[round(y, 0), round(x, 0)+1] # find the closest angle to x & y\n      x <- x + cos(theta) * 0.1 # 0.1 controls how far apart the new x & y \n      y <- y + sin(theta) * 0.1 # are from the previous values\n      if (x > dims - 1 | x < 1) break  # prevents lines going out of bounds\n      if (y > dims | y < 1) break\n      df[i, ] <- c(x, y, j, i)\n    }\n  }\n  df <- df %>% filter(seg != 0) # get rid of empty rows if lise was out of bounds\n  ifelse(j==1, df_new <- df, df_new <- df_new %>% bind_rows(df))\n}\n\nggplot(df_new) + \n  geom_path(aes(x=x, y=y, group=seg, color=step), \n            alpha=0.5, size=0.5, \n            lineend=\"round\", linejoin=\"bevel\") +\n  scale_color_distiller(palette = \"Spectral\") +\n  theme_void() +\n  theme(legend.position=\"none\",\n        panel.background = element_rect(fill = 'black', color = 'black')) +\n  ggtitle(\"One-Sided Starting Points\")\n```\n\n### Change Line Thickness\n\nTo come full circle, I'm using Perlin noise to change the width of the lines.\n\n```{r}\n\nfor (j in 1:400){\n  dims <- nrow(m)\n  # the actual line segment length \n  seg_len <- sample(dims:dims*5, 1)\n  \n  df <- data.frame(x=rep(0, seg_len), y=rep(0, seg_len), seg = rep(0, seg_len))\n  \n  for (i in 1:seg_len){\n    if (i == 1){\n      x <- runif(1, 1, dims-1) # random starting value for x\n      y <- runif(1, 1, dims-1) # random starting value for y\n      df[i, ] <- c(x, y, j)\n    } else {\n      theta <- m[round(y, 0), round(x, 0)+1] # find the closest angle to x & y\n      x <- x + cos(theta) * 0.1 # 0.1 controls how far apart the new x & y \n      y <- y + sin(theta) * 0.1 # are from the previous values\n      if (x > dims - 1 | x < 1) break  # prevents lines going out of bounds\n      if (y > dims | y < 1) break\n      df[i, ] <- c(x, y, j)\n    }\n  }\n  df <- df %>% filter(seg != 0) # get rid of empty rows if lise was out of bounds\n  df$col <- sample(c(\"#3CAEA3\", \"#F6D55C\", \"#ED553B\"), 1)\n  df$wid <- noise_perlin(c(nrow(df), nrow(df)))[1, ]\n  ifelse(j==1, df_new <- df, df_new <- df_new %>% bind_rows(df))\n}\n\n\nggplot(df_new) + \n  geom_path(aes(x=x, y=y, group=seg), \n            color=df_new$col, size=scales::rescale(df_new$wid, to=c(0.1, 2)),\n            lineend=\"round\", linejoin=\"bevel\") +\n  theme_void() +\n  theme(legend.position=\"none\")\n\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Flow Fields","description":"Manual and algorithm-based methods for generating flow fields.","author":"John King","date":"5/26/2022","categories":["R","ggplot2","generative art"],"image":"teaser.png","code-copy":true},"extensions":{"book":{"multiFile":true}}}}}