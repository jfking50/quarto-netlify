{"title":"Substitution Cyphers","markdown":{"yaml":{"title":"Substitution Cyphers","description":"Decrypt a substitution cypher using the Markov Chain Monte Carlo method.","author":"John King","date":"3/30/2020","format":{"html":{"toc":true,"code-fold":true,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false},"categories":["python","cryptology","stochastic methods"],"image":"teaser.png","bibliography":"references.bib"},"headingText":"Cryptography Background","containsRefs":false,"markdown":"\n\nStanford professor Persi Diaconis described an event when a psychologist from the California prison system brought encoded messages obtained from inmates to the Statistics Department's drop-in consulting service and asked if the messages could be decrypted[@diaconis2008]. The problem was tackled by Stanford student Marc Coram, who guessed that the message was encoded using a simple substitution cipher. Using the Markov Chain Monte Carlo (MCMC) method, Coram's algorithm was able to correctly decipher the message without enumerating through all of the possible letter combinations. This paper presents an algorithm in Python that replicates Coram's approach and evaluates some minimum conditions required for the technique to be successful. The Python code used for this project is included as an appendix to this report.\n\n\nText encryption is the process of turning intelligible text into unintelligible text, and text decryption is the opposite process. A cipher is a pair of algorithms the create the encrypted and decrypted texts. The operation of the cipher is controlled by the both the algorithm and a key. The cipher used in the inmates' messages substituted a different symbol for each letter of the alphabet, punctuation, and spaces between words. Instead of using symbols in this project, letters were randomly chosen to substitute for other letters in a string of text.\n\n## Monte Carlo Markov Chain Method\n\nWhen faced with the challenge of deciphering text encoded with a substitution cipher, an initial approach might be to attempt to match letter frequencies in the encoded text with average letter frequencies for the English language. Chen tried this approach and found that it had limited success, correctly decoding just 16 out of 26 letters. Because of this, Coram instead used two letter transition frequencies.\n\n### Two Letter Transitions\n\nFor this project, I obtained a text file of *War and Peace* from www.textfiles.com and counted the number of times each of the two letter combinations appeared. All numbers, punctuation, and spaces were combined into a single category of a non-letter. I used the space character to represent these non-letters in order to have the resulting decrypted text be more readable. I chose *War and Peace* as the reference text because of its length. A longer text produces a larger sample size for calculating statistics on two-letter frequencies. Additionally, a novel is a better choice than a dictionary of the English language because the resulting two-letter frequencies will represent what would be expected in natural language. For example, since the word \"the\" is the most common word in written English, the two-letter pairs of TH and HE should be relatively frequent.\n\n![](teaser.png)\n\nThis is a plot of the normalized transition probabilities that I used to check the accuracy of the Python function. The QU transition stands out, and the TH and HE frequencies are high as expected from the common use of the word \"the\". T is the most common letter to start a word, and D and Y are the most common letters to end a word. These results match expectations, so the function appears to be correct.\n\n### Metropolis-Hastings Algorithm\n\nA state space of the Markov Chain in this application is represented by a unique sequence of each of the 26 letters. For example, if the original text was encoded with a key where only the first two letters were swapped, that would be represented by the state BACDEF...XYZ. Since the order of substitution for encrypted text is unknown, the correct decryption key is one of 26! possible states. Iterating through each of the 26! possibilities is infeasible, and that is where the MCMC approach comes to the rescue.\n\nThe Metropolis-Hastings Algorithm is a technique for randomly sampling from the possible state spaces in such a way as to efficiently converge to the correct decryption. As described in Chen, for each successive pair of characters $\\beta_{1}$, $\\beta_{2}$, the expression $r(\\beta_{1},\\beta_{2})$ records the number of times each particular pair of characters appears in the reference text *War and Peace*. Similarly, $f_{x}(\\beta_{1},\\beta_{2})$ records the number of times each two-letter pair occurs in the target text after it was decrypted with key *x* from the state space. For a particular decryption key *x*, its score function is as follows:[@chen2011]\n\n$$\n\\pi(x)=\\prod_{\\beta_{1},\\beta_{2}}r(\\beta_{1},\\beta_{2})^{f_{x}(\\beta_{1},\\beta_{2})}\n$$\n\nWhen I implemented this expression in Python, there were significant numerical errors due to multiplying large numbers. Therefore, I modified the expression so that the target text letter count is multiplied by the logarithm of the reference text count. I then added the products of all of the two-letter pairs since adding logarithms is equivalent to successive multiplication. For example, if the number of times AB appeared in the decrypted text was 12 and the number of times AB appeared in *War and Peace* was 3,437, then 12 was multiplied by log(3437). This product was added to the product of every other possible two-letter pair for a total score for that particular decryption key. This logic is implemented in the following code where in the last line, `key_score` represents the score for the decryption key, `v` represents a two-letter count in the target text, and `trans_counts[k]` represents the same two-letter pair count in *War and Peace*.\n\n``` {{python}}\nfor k,v in target_counts.items():\n        if k in trans_counts:\n            key_score += v * math.log(trans_counts[k])\n```\n\nAfter calculating a score for the decryption key, a proposal key is generated by randomly choosing two letters from the key and swapping their positions. So if A and G are randomly chosen and A mapped to S and G mapped to Y, then in the proposed key, A maps to Y and G maps to S. A score for the proposed key is calculated and compared to the current key. If the proposed key's score is greater than the current key's score, the score ratio is greater than one, and it produces a decrypted text with letter transitions that more closely match the reference text, so it is accepted as the new decryption key. If the score ratio is less than one, then the proposed key is accepted with a probability equal to the score ratio. This allows lower probability keys to be explored during the random walk. In Python, it is implemented by drawing a random number from a uniform distribution ranging from 0 to 1 and comparing it to the score ratio. The Python implementation of this logic is below. Note that the exponent of the difference of the scores is required to negate the logarithm of the two-letter count described earlier.\n\n``` {{python}}\n#generate a proposed decryption key and get scores\nproposed_decrypt_key = get_proposed_key(current_decrypt_key)\ncurrent_score = score(current_decrypt_key, encoded_text, trans_counts)\nproposed_score = score(proposed_decrypt_key, encoded_text, trans_counts)\n\n#calculate the acceptance probability\nap = min(1, math.exp(proposed_score - current_score))\n\n#generate a random number between 0 and 1\nrunif = np.random.uniform()\n\n#accept the proposed key if the random number is less than the acceptance probability\nif runif <= ap: accept_proposed_key = True\nelse: accept_proposed_key = False\nif accept_proposed_key: current_decrypt_key = proposed_decrypt_key\n```\n\n## Results\n\nIn this section, I will test the algorithm on two different short texts, which I refer to as the target texts, using *War and Peace* as the reference text for letter transition probabilities. The first target text is taken from a passage in the movie *Strange Brew*. I chose this text to represent typical spoken English, and it contains 12 sentences, 202 words, and 944 characters. I will repeat the test on the movie passage using increasingly shorter segments of the passage to determine the approximate minimum length of text needed. I will also test the algorithm on the movie massage by using a shorter reference text *Alice's Adventures in Wonderland*. The other target text is a portion of the decrypted text obtained from the prison psychologist. Because this text contains slang, mis-spellings, and several words in Spanish, it should provide a challenge to the decryption algorithm. For this target text, I will again use *War and Peace* as the reference text.\n\n```{python}\nimport numpy as np\nimport math\nimport pandas as pd\n```\n\n```{python}\ndef get_trans_counts(plaintext):\n    '''takes .txt file and creates a dictionary with two-letter combinations as keys and their counts as values.\n    returns a dictionary of the counts in the form {AB:343, AC:112, etc}'''\n    trans_counts = {}\n    chars = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n    f = open(plaintext)\n    wp = []\n    for line in f:\n        wp.append(line)\n    f.close()\n    for line in wp:\n        #convert to upper case\n        line = str.upper(line)\n        #remove the \\n newline characters at the end of the line\n        line = line[0:len(line)-1]\n        #count the number of two letter pairs\n        for i in range(len(line)-1):\n            twoletter_key = line[i] + line[i+1]\n            #two consecutive letters\n            if (line[i] in chars) & (line[i+1] in chars):\n                if twoletter_key not in trans_counts: trans_counts[twoletter_key] = 1\n                else: trans_counts[twoletter_key] += 1\n            #non-letter followed by a letter\n            elif (line[i] not in chars) & (line[i+1] in chars):\n                twoletter_key = \" \" + line[i+1]\n                if twoletter_key not in trans_counts: trans_counts[twoletter_key] = 1\n                else: trans_counts[twoletter_key] += 1\n            #letter followed by a non-letter\n            elif (line[i] in chars) & (line[i+1] not in chars):\n                twoletter_key = line[i] + \" \"\n                if twoletter_key not in trans_counts: trans_counts[twoletter_key] = 1\n                else: trans_counts[twoletter_key] += 1\n            #two non-letters\n            elif (line[i] not in chars) & (line[i+1] not in chars):\n                twoletter_key = \" \" + \" \"\n                if twoletter_key not in trans_counts: trans_counts[twoletter_key] = 1\n                else: trans_counts[twoletter_key] += 1\n    return trans_counts\n\ndef map_key(key):\n    '''given a encryption or decryption key, returns a dictionary where the dictionary key is the letter from the key\n    and the value is the letter of the alphabet it maps to in the form {A:R, B:W, C:O, etc}'''\n    alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n    mapping = {}\n    for i in range(len(key)): mapping[alphabet[i]] = key[i]\n    return mapping\n\ndef apply_key(key, text):\n    '''encodes/decodes text given a de/encryption key (a sequence of 26 letters) and a string of text\n    returns a new text (string)'''\n    mapped_text = \"\"\n    #convert the text to a list\n    text = list(text)\n    #get the mapping from map_key\n    mapping = map_key(key)\n    #apply the mapping based on the key\n    for letter in text:\n        #convert to upper case\n        letter = str.upper(letter)\n        if letter in mapping: mapped_text += mapping[letter]\n        else: mapped_text += \" \"\n    return mapped_text\n\ndef score(key, text, trans_counts):\n    '''calculates the score of a decryption key based on it's log-likliness to the referece text transition counts.\n    Returns a score value (float)'''\n    #get the current mapping\n    mapping = map_key(key)\n    #decode the text based on the mapping\n    decoded = apply_key(key, text)\n    key_score = 0\n    target_counts = {}\n    chars = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n    #strip the text\n    stripped_text = decoded.strip()\n    #convert the target text into a list of characters\n    text_list = list(stripped_text)\n    #count the number of two letter pairs in the target text\n    for i in range(len(text_list)-1):\n        twoletter_key = text_list[i] + text_list[i+1]\n        #two consecutive letters\n        if (text_list[i] in chars) & (text_list[i+1] in chars):\n            if twoletter_key not in target_counts: target_counts[twoletter_key] = 1\n            else: target_counts[twoletter_key] += 1\n        #non-letter followed by a letter\n        elif (text_list[i] not in chars) & (text_list[i+1] in chars):\n            twoletter_key = \" \" + text_list[i+1]\n            if twoletter_key not in target_counts: target_counts[twoletter_key] = 1\n            else: target_counts[twoletter_key] += 1\n        #letter followed by a non-letter\n        elif (text_list[i] in chars) & (text_list[i+1] not in chars):\n            twoletter_key = text_list[i] + \" \"\n            if twoletter_key not in target_counts: target_counts[twoletter_key] = 1\n            else: target_counts[twoletter_key] += 1\n        #two non-letters\n        elif (text_list[i] not in chars) & (text_list[i+1] not in chars):\n            twoletter_key = \" \" + \" \"\n            if twoletter_key not in target_counts: target_counts[twoletter_key] = 1\n            else: target_counts[twoletter_key] += 1\n    for k,v in target_counts.items():\n        if k in trans_counts:\n            key_score += v*math.log(trans_counts[k])\n    return key_score\n\ndef get_proposed_key(key):\n    '''Takes a decryption key, randomly selects two letters, and swaps they keys for those letters. So if A mapped to X\n    and B mapped to Q, then A maps to Q and B to X.\n    Returns a new decryption key (string)'''\n    proposed_key = \"\"\n    chars = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n    #randomly select two letters to swap\n    char1, char2 = np.random.choice(chars, size=2, replace=False)\n    #create a new key, swapping letters in the old key\n    new_key = list(key)\n    for i in range(len(new_key)):\n        if new_key[i] == char1: index1 = i\n        if new_key[i] == char2: index2 = i\n    new_key[index1] = char2\n    new_key[index2] = char1\n    for letter in new_key:\n        proposed_key += letter\n    return proposed_key\n```\n\n```{python}\n### MAIN PROGRAM\n\n#get letter transition counts for reference text\ntrans_counts = get_trans_counts('wp_full.txt')  # war and peace\n\ntarget_text = \"to bat—rb. con todo mi respeto. i was sitting down playing chess with \\\ndanny de emf and boxer de el centro was sitting next to us. boxer was \\\nmaking loud and loud voices so i tell him por favor can you kick back \\\nhomie cause im playing chess. a minute later the vato starts back up again \\\nso this time i tell him con respecto homie can you kick back. the vato \\\nstop for a minute and he starts up again so i tell him check this out shut \\\nthe fuck up cause im tired of your voice and if you got a problem with it \\\nwe can go to celda and handle it. i really felt disrespected thats why i \\\ntold him. anyways after i tell him that the next thing I know that vato \\\nslashes me and leaves. by the time i figure im hit i try to get away but \\\nthe c.o. is walking in my direction and he gets me right by a celda. so i \\\ngo to the hole. when im in the hole my home boys hit boxer so now b is \\\nalso in the hole. while im in the hole im getting schoold wrong. \" \n\nalphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n#generate a random encryption key\nchars = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\nencrypt_list = list(np.random.choice(chars, size=26, replace=False))\nencrypt_key = \"\"\nfor i in encrypt_list:\n    encrypt_key = encrypt_key + i\nencrypt_test =\"abcdefghijklmnopqrstuvwxyz\"\ntest_key = apply_key(encrypt_key, encrypt_test)\n\n#encrypt the target text\nencoded_text = apply_key(encrypt_key, target_text)\n\n#generate a random decryption key\ndecrypt_list = list(np.random.choice(chars, size=26, replace=False))\ncurrent_decrypt_key = \"\"\nfor i in decrypt_list:\n    current_decrypt_key = current_decrypt_key + i\n\n#Results!\n\nprint('Unencrypted text:\\n', target_text)\nprint('\\nEncrypted text:\\n', encoded_text)\nprint('\\n')\n\nfor iters in range(20001):\n    proposed_decrypt_key = get_proposed_key(current_decrypt_key)\n    current_score = score(current_decrypt_key, encoded_text, trans_counts)\n    proposed_score = score(proposed_decrypt_key, encoded_text, trans_counts)\n\n    #calculate the acceptance probability based on the ratio of the proposed and current scores\n    ap = min(1, math.exp(proposed_score - current_score))\n\n    #generate a random number between 0 and 1\n    runif = np.random.uniform()\n\n    #accept the proposed key only if the random number is less than the probability of acceptance\n    if runif >= ap: accept_proposed_key = False\n    else: accept_proposed_key = True\n    if accept_proposed_key: current_decrypt_key = proposed_decrypt_key\n\n    #print every 1000th iteration\n    if iters%500 == 0:\n        print('Iter:', iters, apply_key(current_decrypt_key, encoded_text)[0:99])\n        test = apply_key(encrypt_key, alphabet)\n        check = apply_key(current_decrypt_key, test)\n        correct = 0\n        for i in range(len(alphabet)):\n            if alphabet[i] == check[i]: correct += 1\n        #print('Number of correctly decoded letters:', correct)\n\nprint('\\nDecrypted text:')\nprint(apply_key(current_decrypt_key, encoded_text))\n\n#get number of correct letters\ntest = apply_key(encrypt_key, alphabet)\ncheck = apply_key(current_decrypt_key, test)\ncorrect = 0\nfor i in range(len(alphabet)):\n    if alphabet[i] == check[i]: correct += 1\nprint('\\n')\n#print(alphabet)\n#print(check)\nprint('Number of correctly decoded letters:', correct)\n```\n\nNot bad! I think it's fascinating that the algorithm was also successful on text that contained slang, mis-spellings, and occasional Spanish as in the above example.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Substitution Cyphers","description":"Decrypt a substitution cypher using the Markov Chain Monte Carlo method.","author":"John King","date":"3/30/2020","categories":["python","cryptology","stochastic methods"],"image":"teaser.png","bibliography":["references.bib"],"code-copy":true},"extensions":{"book":{"multiFile":true}}}}}