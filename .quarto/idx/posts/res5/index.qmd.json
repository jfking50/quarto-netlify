{"title":"Resolution 5 Fractional Factorial Designs","markdown":{"yaml":{"title":"Resolution 5 Fractional Factorial Designs","description":"Use of a Walsh matrix to generate an experimental design.","author":"John King","date":"5/21/2021","format":{"html":{"toc":true,"code-fold":false,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"message":false,"echo":true},"categories":["R","design of experiments"],"image":"teaser.png"},"headingText":"The Problem","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(tidyverse)\nlibrary(formattable)\nlibrary(kableExtra)\n```\n\n\nAt work, I needed to create a resolution V (R5) fractional factorial design for use in a study of the relative effectiveness of various modernization programs. The computer network on which I was working was an isolated network completely disconnected from the internet with specific versions of software installed to support the type of work done. When I've needed to create an R5 design in the past, I either used the `FrF2` R package or a Ruby script written by Dr. Paul Sanchez at the Naval Postgraduate School. Neither of those were viable options on the isolated computer network, so I needed to create an R5 design for 14 factors from scratch. Since base R was available for this task, that seemed the path of least resistance.\n\n## Resolution V Designs\n\nSo why did I need to create an R5 design, and what is one? The study involved 14 modernization programs, and I wanted to evaluate the contribution of each modernization program compared to its current equivalent. That means I had 14 factors with two levels each: current and future. The approach was to represent each of the factors at both levels in a computer simulation, query the simulation results for one or more measure of effectiveness, and fit one or more machine learning models to the results to understand the relationship between the factors and the measures of effectiveness.\n\nOne approach to generate these results is to run the simulation for each unique combination of factors and their levels. 14 factors at 2 levels each would require $2^{14} = 16,384$ simulation runs. A benefit of this design (called a full factorial design) is that it allows for the evaluation of main effects, 2-way interactions, 3-way interactions, and all the way up to 13-way interactions. Full factorial designs are easy to create in R using the `expand.grid()` function. An example for thee factors is shown below, and this is often referred to as a design matrix. Note the use of -1 and 1 to represent the two factor levels instead of 0 and 1 will be explained later. When evaluating the properties of the design itself, -1 and 1 is necessary (and will be demonstrated later), but we re-code to 0 and 1 when applying machine learning methods to the results.\n\n```{r}\nexpand.grid(\n  f1 = c(-1, 1),\n  f2 = c(-1, 1),\n  f3 = c(-1, 1)\n  )\n```\n\nFor this study, each simulation took approximately one hour of computing time, and the network was fairly small, so there were a limited number of machines on which to farm out all of these runs. Each simulation also produced approximately 10Gb of output. Unfortunately, the computer network simply didn't have the computing power or storage space to handle all 16,384 runs.\n\nClearly, we needed to reduce the number of simulation runs to something feasible. That's what an R5 design does for us, but it comes at a cost. If we were willing to give up the ability to evaluate 3-way and higher order interactions (we were), then we could drastically reduce the number of simulation runs. For example, to evaluate main effects and all 2-way interactions for 14 factors, we know we need at least $1 + 14 + \\left(\\begin{array}{c}14\\\\ 2\\end{array}\\right) = 106$ simulation runs to provide the necessary degrees of freedom - a huge decrease from 16,384. We might need more than 106 runs, but not orders of magnitude more.\n\nSo we know we needed a design matrix with at least 106 rows, but how do we create it? Montgomery (2013) discusses a method that uses the smallest full factorial design with more rows than needed for the R5 design as a basis. The smallest full factorial design with at least 106 rows is $2^7 = 128$, so we have a design matrix of size 128 x 128. From this matrix, we would then select 14 columns to represent our 14 factors. Montgomery (2013) specifies which columns to select for R5 designs but only up to 10 factors. One option for creating our design would be to continue with this approach of using full factorial designs as a basis. Dr. Sanchez's Ruby script uses a different option, which piqued my interest. Instead of a full factorial design as the basis, his script uses a naturally ordered Walsh matrix (also referred to as a Hadamard matrix) as the basis.\n\n## Walsh Matrices\n\nAn internet search will produce plenty of options to learn all about Walsh matrices, but I'll boil that down into their properties that matter for this purpose.\n\n-   As with full factorial designs, they are square with dimensions of $2^x$.\n\n-   They consist entirely of binary values.\n\n-   All columns (and less importantly, rows) are orthogonal.\n\n-   They are easy to generate.\n\nThe smallest Walsh matrix is 2x2 with the following values.\n\n```{r}\nw <- matrix(c(1, 1, 1, -1), nrow = 2)\nw\n```\n\nThe Kronecker product of two 2x2 Walsh matrices creates a 4x4 Walsh matrix.\n\n```{r}\nbig_w <- w %x% w\nbig_w\n```\n\nIf you're like me and have never heard of the Kronecker product before, I've highlighted and divided the matrix into sections to illustrate what it does. Take the upper left value in the right hand matrix and multiply it by the entire left hand matrix. Place that matrix in the upper left quadrant of the new matrix `big_w`. Then cycle through each value in the right hand matrix in the same manner.\n\n```{r echo=FALSE}\nas.data.frame(big_w) %>%\n  mutate(V1 = color_tile(\"steelblue\", \"white\")(V1),\n         V2 = color_tile(\"steelblue\", \"white\")(V2),\n         V3 = color_tile(\"steelblue\", \"white\")(V3),\n         V4 = color_tile(\"steelblue\", \"white\")(V4)) %>%\n  kable(\"html\", align = 'c', escape = FALSE) %>%\n  row_spec(1:4, color=\"black\") %>%\n  column_spec(2, border_right = \"2px solid black\") %>%\n  row_spec(2, extra_css = \"border-bottom: 2px solid black\")\n```\n\nTo create an 8x8 matrix, take the Kronecker product of the 4x4 and 2x2 Walsh matrices. Repeating this process will generate increasingly large matrices bounded only by available RAM.\n\n```{r}\nbig_w <- big_w %x% w\nbig_w\n```\n\n## Determine Valid Matrix Size and Column Indices\n\nLet's start with the smallest case possible: create an R5 design for two factors. The first step is to identify the theoretical minimum number of runs using the method described earlier: intercept + \\# main effects + \\# interactions. Then start with the smallest $2^x$ Walsh matrix with at least that many rows. For two factors, that's 4 rows, so we need a 4x4 Walsh matrix. We also know we're going to drop the first column, so we have 3 columns to work with for our 2 factors.\n\n```{r}\n# minimum number of rows\n1 + 2 + choose(2, 2) \n\n# get Walsh matrix and display only last three columns\nbig_w <- w %x% w\nbig_w\n```\n\nWe don't need to check if main effects are aliased because we know they aren't based on the properties of Walsh matrices. We just need to check whether main effects are aliased with 2-way interactions. Later we'll also need to check whether 2-way interactions are aliased with any other 2-way interactions. We can skip that for 2 factors since there's only one 2-way interaction. So, we have three possible candidates for our 2 factors: columns 2, 3, and 4. Let's just start at the left and work to the right as needed. We'll select columns 2 and 3 and check the correlation between the two main effects with the interaction term. If no correlation exists, then we'll keep track of the size of the matrix we tried and the indices of the columns that produced no correlation.\n\n```{r}\n# get the interaction between the candidate columns\nint_term <- big_w[, 2] * big_w[, 3]\n\n# check for correlation of both main effects and the interaction term\ncor(big_w[, 2], int_term)\ncor(big_w[, 3], int_term)\n```\n\nSince there is no correlation, we know that for 2 factors, we can use columns 2 and 3 from a 4x4 matrix. If we weren't able to find a combination of columns that worked, we'd increase the size of the underlying Walsh matrix and repeat the process. The `pwr` vector will keep track of the number of times we needs to use the Kronecker product to generate the correct sized matrix. For 2 factors and a 4x4 matrix, we use the kronecker product once, so we add a 1 to the vector at an index of 2.\n\n```{r}\nidx <- c(2, 3)\npwr <- c(0, 1)\n```\n\n## Adding Factors\n\nNow that we know the indices and matrix size for two factors, we can use this same algorithm to successively add one more factor at a time.\n\n```{r}\n# minimum number of rows\n1 + 3 + choose(3, 2)\n```\n\nSo we need at least an 8x8 matrix.\n\n```{r}\nbig_w <- big_w %x% w\ndim(big_w)\n```\n\nWe're already using columns 2 and 3, so for our third factor, we'll start with column 4 as a candidate and check for non-zero correlation. If it fails the correlation checks, we'll move on to column 5, and continue until we find a valid column. If we find a valid column, we'll record the column index number.\n\n```{r}\nfn <- function(x){m[, x[1]] * m[, x[2]]}\n\n# loop through the candidate columns\nfor (i in (1+max(idx)):ncol(big_w)){\n  # create a new dataframe with just the columns of interest\n  m <- big_w[, c(idx, i)]\n  # check for correlation. If none found, save the column number and stop the loop.\n  if (all(colSums(cor(cbind(m[, ncol(m)], combn(1:(length(idx)+1), 2, fn)))) == 1)){\n    idx <- c(idx, i)\n    break\n  }\n}\nidx\n```\n\nLooks like column 4 failed the test but column 5 passed. We found a valid column, so we'll also record the number of times we invoked the Kronecker product (2) in the `pwr` vector power at index 3 (because it corresponds with 3 factors).\n\n```{r}\npwr <- c(pwr, 2)\n```\n\n## Continuing On\n\nFrom here forward, it's the same process applied to each new column. However, once the number of indices in the `idx` vector gets into the 30s, the algorithm as written starts slowing down drastically. By avoiding checking correlations that have been checked during earlier iterations and improving the efficiency of my code, I was able to generate R5 matrices for up to 70 factors. At that point, the base matrix dimensions were approximately 32,000 by 32,000 which required 8GB of RAM. My personal computer has 16GB of RAM, and so due to R's copy on modify behavior, I was unable to create a matrix of that size. I've yet to be involved in a DOE study where more than 70 factors were being considered, so I'll just accept that limitation for now. The full algorithm for up to 20 factors is shown below.\n\n```{r}\n# function to create a Walsh matrix of a certain size.\n# Since I iterate from 2:p, I get the size of the Walsh matrix as 2^p\nres5 <- function(fct, p){\n  a <- matrix(c(1,1,1,-1), nrow=2)\n  w <- matrix(c(1,1,1,-1), nrow=2)\n  for (i in 2:p){w <- w %x% a}\n  w\n}\n\nidx <- c(2, 3)\npwr <- c(0, 1)\n\n# function to check aliasing between main effects and two-way interactions\none_two <- function(i) {sum(m[, ncol(m)] == m[, int1[1, i]] * m[, int1[2, i]]) == nrow(m) | \n    sum(m[, ncol(m)] == -(m[, int1[1, i]] * m[, int1[2, i]])) == nrow(m)}\n\n# iterate through new factors\nfor (f in 3:20){\n  # get the minimum size of the Walsh matrix\n  new_p <- max(ceiling(log2(1 + f + choose(f, 2))), pwr[length(pwr)])\n  # try the smallest matrix size first, then try one bigger \n  for (ps in c(new_p, new_p+1)){\n    p_worked <- FALSE\n    dm <- res5(f, ps)\n    # get the various combinations of interactions\n    int1 <- combn(1:length(idx), 2)\n    int2 <- combn(1:(length(idx)+1), 2)\n    # filter out the interactions we've already checked\n    int_n <- int2[, int2[2, ]==f]\n    # iterate through the new potential matrix columns\n    for (k in (max(idx)+1):ncol(dm)){\n      m <- dm[, c(idx, k)]\n      # check new factor against 2-way interaction terms\n      keepchecking <- TRUE\n      if(any(1:ncol(int1) %>% purrr::map_lgl(function(x) one_two(x)))) {next}\n      # check 2-way interactions vs. 2-way interactions\n      if (keepchecking){\n        for (j in 1:ncol(int1)){\n          for (i in 1:ncol(int_n)){\n            if(cor(m[, int1[1, j]] * m[, int1[2, j]], m[, int_n[1, i]] * m[, int_n[2, i]]) > 0){\n              keepchecking <- FALSE\n              break\n            }\n          }\n          if (!keepchecking){break}\n        }\n      }\n      if (keepchecking){\n        idx <- c(idx, k)\n        pwr <- c(pwr, ps)\n        p_worked <- TRUE\n        break}\n    }\n    if (p_worked){break}\n  }\n}\n```\n\nThe column indices are:\n\n```{r}\nidx\n```\n\nAnd the associated sizes of the Walsh matrices are:\n\n```{r}\npwr\n```\n\nNow we have everything needed to create R5 designs for up to 20 factors. We'll wrap everything up in a new function and replace all -1's with 0's for convenience. Then we'll display the first few rows of the design matrix for 14 factors.\n\n```{r}\nr5 <- function(fct){\n  idx <- c(2, 3, 5, 9, 16, 17, 33, 52, 65, 86, 107, 129, 151, 172, 220, \n           238, 248, 257, 280, 298)\n  pwr <- c(0, 1, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9)\n  \n  a <- matrix(c(1,1,1,-1), nrow=2)\n  w <- matrix(c(1,1,1,-1), nrow=2)\n  for (i in 2:pwr[fct]){w <- w %x% a}\n  # select only the columns we need\n  w <- w[, idx[1:fct]]\n  # replace -1 with 0\n  w[w == -1] <- 0\n  w\n}\n\nhead(r5(14))\n```\n\nThe number of runs required for this design is simply `nrow(r5(14))` = `r nrow(r5(14))`.\n\nI am currently working with a colleague to develop an R package that uses the methodology described above to generate Resolution III, V, and VII fractional factorial designs. The package will also provide the ability to generate nearly orthogonal Latin hypercube designs.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Resolution 5 Fractional Factorial Designs","description":"Use of a Walsh matrix to generate an experimental design.","author":"John King","date":"5/21/2021","categories":["R","design of experiments"],"image":"teaser.png","code-copy":true},"extensions":{"book":{"multiFile":true}}}}}