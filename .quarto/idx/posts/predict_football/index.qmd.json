{"title":"Predictive Modeling","markdown":{"yaml":{"title":"Predictive Modeling","description":"A variety of machine learning models to predict beating the spread.","author":"John King","date":"3/12/2022","format":{"html":{"toc":true,"code-fold":false,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"message":false,"echo":true},"categories":["R","ggplot2","college football","sports analytics","machine learning"],"image":"teaser.png"},"headingText":"Get the Data","containsRefs":false,"markdown":"\n\nContinuing with the streak of posts about college football posts, here I finally get into developing some models to predict the winning team and margin of victory of college football games. For this analysis, I was inspired by [this post](https://blog.collegefootballdata.com/lessons-from-picking-the-2022-cfb-season/) that mentioned a leader board for people who picked winners from the 2021-2022 season. Reminds me of Kaggle competitions, which I did once for fun and [wrote about it](https://jfking.netlify.app/posts/ames/).\n\nI also found [this published paper](https://content.iospress.com/articles/journal-of-sports-analytics/jsa190314) both extremely interesting and helpful because it lays out in detail the author's analytic methodology for building their predictive model. The first part of this post is my attempt at replicating their technique using a different data source (collegefootball.com's [API](https://api.collegefootballdata.com/api/docs/?url=/api-docs.json)) and using data from the 2017-2020 seasons to predict games of the 2021 season. Spoiler, my initial tree-based models don't perform nearly as well as theirs, and I eventually try a neural network with much better success.\n\n\nFirst, I'll load data I previously obtained via the API I mentioned above. If you want to see how to make those API calls, I explain it in [this post](https://jfking.netlify.app/blog/oregon-football/). The data in `/games/teams` has a bunch of game result data that are similar to the data used in the article above.\n\n```{r}\ngs <- readRDS(\"gameStats.RData\")\ngs <- type.convert(gs, as.is = TRUE)\nhead(gs)\n```\n\nI also want to get the list of all of the FBS teams because I want to filter out the games played against non-FBS teams. There's a bunch of data in that table, but I'm really only interested in the `school` column.\n\n```{r}\nfbs <- readRDS(\"fbs_teams.RData\")\nhead(fbs)\n```\n\nNow I'll get a vector of all of the game IDs from the first table in which a non-FBS team played. Here are the first three.\n\n```{r}\nlibrary(dplyr) # I'm going to need to do some data wrangling\n\nfcsIDs <- gs %>% filter(!school %in% (fbs %>% .$school)) %>% .$id\nfcsIDs[1:3]\n```\n\nNow I apply the filter and separate out some of the columns. For example, the `totalPenaltiesYards` column is formatted as penalties-yards, so for example 3-25. I'll then create a new column that divides one of those values by the other so that I get a single `yardsPerPenalty` value. I'll also convert the time of possession into minutes and get rid of columns I no longer need.\n\n```{r}\nlibrary(tidyr) # needed for the separate function below\n\ngs <- \n  gs %>%\n  filter(!id %in% fcsIDs) %>%\n  separate(totalPenaltiesYards, \n           into = c(\"penalties\", \"penaltiesYards\"), convert = TRUE) %>%\n  separate(completionAttempts, \n           into = c(\"passCompletions\", \"passAttempts\"), convert = TRUE) %>%\n  separate(possessionTime, into = c(\"posMM\", \"posSS\"), convert = TRUE) %>%\n  mutate(posTime = posMM * 60 + posSS,\n         yardsPerPenalty = penaltiesYards / penalties,\n         passEfficiency = passCompletions / passAttempts,\n         yardsPerPlay = (yardsPerPass + yardsPerRushAttempt) / 2) %>%\n  select(-totalYards, -posMM, -posSS, -fourthDownEff, -thirdDownEff)\n```\n\nI found that there are a number of NAs in the data. For this demonstration, I'll just convert them all to 0. If I was cleaning this data for an actual competition or to try to beat Vegas, I'd take a much harder look at those NAs and treat them carefully.\n\n```{r}\ngs[is.na(gs)] <- 0\n```\n\nI also found that there's a game ID that's repeated, so I'll filter out the repeat.\n\n```{r}\n# there's an id that's repeated - there should be two games for each ID\ngs %>% group_by(id) %>% count() %>% filter(n > 2)\n\n# take a look at that ID\ngs %>% filter(id == 401309547)\n\n# filter out the ID with zeros in the rushingTDs column\ngs <- gs %>% filter(!(id == 401309547 & rushingTDs == 0))\n```\n\nIn the article, they did some feature engineering that I'll replicate here.\n\n```{r}\ngs <- \n  gs %>% \n  mutate(offensePoints = (rushingTDs + passingTDs) * 7 + kickingPoints,\n         offenseYards = netPassingYards + rushingYards) %>% \n  arrange(id)\n\n```\n\nThey also created some features for one team based on how the other team performed. Doing this in the original `gs` dataframe made my head hurt, so I split it into separate dataframes for the home and away teams. While I'm at it, I'll also calculate `MOV`, the margin of victory.\n\n```{r}\nhome <- gs %>% filter(homeAway == \"home\")\naway <- gs %>% filter(homeAway == \"away\")\n\nhome <- \n  home %>% \n  mutate(\n    defensePointsAllowed = away$offensePoints,\n    defenseYPPAAllowed = away$yardsPerPass,\n    defenseYPRAAllowed = away$yardsPerRushAttempt,\n    defensePassYardsAllowed = away$netPassingYards,\n    defenseRushYardsAllowed = away$rushingYards,\n    defenseYardsPerPlayAllowed = away$yardsPerPlay,\n    forcedPenaltyYards = away$penaltiesYards,\n    forcedTO = away$turnovers,\n    MOV = points - away$points\n  )\n\naway <- \n  away %>%\n  mutate(\n    defensePointsAllowed = home$offensePoints,\n    defenseYPPAAllowed = home$yardsPerPass,\n    defenseYPRAAllowed = home$yardsPerRushAttempt,\n    defensePassYardsAllowed = home$netPassingYards,\n    defenseRushYardsAllowed = home$rushingYards,\n    defenseYardsPerPlayAllowed = home$yardsPerPlay,\n    forcedPenaltyYards = home$penaltiesYards,\n    forcedTO = home$turnovers,\n    MOV = points - home$points\n  )\n```\n\nI also wanted to get each team's Elo score,which I found in the `/games` data via the API. For some reason, I grabbed the pregame Elo score instead of the post-game Elo, but that's fine. I'll account for that later. I'll also filter out those games using the game IDs in the `home` dataframe. The `/games` data also contains a boolean `neutral_site`, which will be useful. There's always a home and away team in every game (as indicated in the `homeAway` column) even if the game is played on a neutral site. If I want to correctly factor in whether a team has a home field advantage, I'll need to account for those games played at a neutral site.\n\n```{r}\neloSite <- readRDS(\"eloSite.RData\") %>% as_tibble()\n\neloSite <- eloSite %>% filter(id %in% (home %>% .$id))\n\nhead(eloSite)\n```\n\nNow I'll combine that data with the `home` and `away` dataframes.\n\n```{r}\nhome <-\n  home %>% \n  left_join(eloSite %>% \n              select(id, home_team, home_pregame_elo, neutral_site),\n            by = c(\"id\" = \"id\", \"school\" = \"home_team\")) %>%\n  rename(\"elo\" = \"home_pregame_elo\")\n\naway <-\n  away %>% \n  left_join(eloSite %>% \n              select(id, away_team, away_pregame_elo, neutral_site),\n            by = c(\"id\" = \"id\", \"school\" = \"away_team\")) %>%\n  rename(\"elo\" = \"away_pregame_elo\")\n```\n\nThe authors explained that their methodology didn't use raw game results. Instead, they used seasonal cumulative means. Let's take `rushingTDs` for an example. Say a given team in week 1 had 1 rushing TD. Week 1 results are unchanged. If they scored 2 rushing TDs in week 2, then the cumulative mean becomes 1.5 and so on through the weeks. At the beginning of the next season, reset and start over. Hopefully, that makes sense.\n\n```{r}\n# re-combine the home and away dataframes into one long dataframe\nha <- \n  bind_rows(home, away) %>% \n  arrange(school, year, week)\n\n# I want to calculate the cumulative MOV mean, but I also need to preserve the\n# actual MOV as the response variable.\nmov_actual <- ha %>% .$MOV \n\n# now calculate the cumulative means\ncmeans<-\n  ha %>%\n  group_by(school, year) %>%\n  summarize_at(vars(c(3:52)), cummean) %>%\n  ungroup()\n\nhead(cmeans)\n```\n\nThere are a few columns from the `ha` dataframe, like the game ID, schools names, the week, the year, etc. that I don't want to have a cumulative mean - I want the original columns. So I'll select those columns and combine them with the cumulative means. Then I'll add the actual MOV results for use as the predictor variable.\n\n```{r}\nha <- bind_cols(ha[, c(1:3, 5, 6, 55, 56)], cmeans[, c(3, 5:52)])\nha$MOV_actual <- mov_actual\n\nhead(ha)\n```\n\nI also want to include the spread as a predictor variable, which I can get via the API from `/lines`.\n\n```{r}\nspread <- readRDS(\"spread.RData\")\nhead(spread)\n```\n\nNow I'll deal with the neutral site column since the dataframe is merged back together. I'm going to make a HFA column that's a 1 for the home team at their home field, a -1 for the away team, and a 0 for both teams at a neutral site. Then I'll add the pre-game spread for the home and away teams.\n\n```{r}\nha <-\n  ha %>%\n  mutate(HFA = case_when(\n    homeAway == \"home\" & !neutral_site ~ 1,\n    homeAway == \"away\" & !neutral_site ~ -1,\n    neutral_site ~ 0)) %>% \n  left_join(spread, by = \"id\") %>% \n  mutate(spread = ifelse(homeAway == \"home\", home_spread, -home_spread))\n```\n\nSomething else I want to add is each team's seasonal win/loss record in the for of the percent of games they've won. I keep adding more and more predictors. We'll find out later if any of it will even be useful.\n\n```{r}\nha <- \n  ha %>%\n  mutate(wins = ifelse(MOV_actual > 0, 1, 0)) %>% \n  group_by(school, year) %>%\n  mutate(games = row_number(),\n         cumwins = cumsum(wins),\n         winPct = cumwins / games) %>%\n  select(-wins, -games, -cumwins)\n```\n\nOk, this is where things get a little complicated. But first, a sidebar. I wrote this code over the course of a few weekends. Until this particular project, I'd never dealt with data where there are \"sides\" to think about. It took me a while to wrap my mind around it, and this is code from my first efforts where I was just trying to find \"a way\" to get things done. Pure brute force. Later you'll see that I came up with a much better (and faster) way to do what I about to demonstrate. All part of the sausage-making the way I look at it.\n\nThe idea here is that I wanted to account for home field advantage. It's a definite thing with a measurable effect. I'll demonstrate using the `home` dataframe from earlier. I'll remove games played at a neutral site, and get the mean margin of victory.\n\n```{r}\nhome %>% \n  filter(!neutral_site) %>%\n  summarize(meanMOV = mean(MOV))\n```\n\nHome teams win by almost 4 points on average. We can also check to see if the mean MOV is statistically significant. I'll use the Wilcoxon signed rank test because *I'm certain* the data are not normally distributed - they're football scores, after all. I'll do a one-sided test where the null hypothesis is that the mean MOV is 0.\n\n```{r}\nwilcox.test(home %>% \n              filter(!neutral_site) %>% .$MOV, \n            alternative = \"greater\")\n```\n\nBased on that p-value, we reject the null hypothesis at the 95% confidence level. Right, so home field advantage is a real thing, and I need to account for it.\n\nTo do that, I wanted to get away from the idea of home team and away team and instead think of them more generically by randomly picking one team as \"the team\" and the other as \"the opponent\". My `ha` dataframe is still grouped by `school` and `year`, so I'll ungroup it and call it my end-of-week results data - it's a mental trick so I think about things differently. Then I'll get all of the unique game IDs.\n\n```{r}\neowResults <- ha %>% ungroup()\n\nids <- sort(unique(eowResults %>% .$id))\n```\n\nNext, I'll loop over the ID. For each ID, I'll start by picking out the common columns (id, week, and year), and then identify one team as team1 and the other as team2. For the first game, and for column-naming consistency as I build this new dataframe `df`, team 1 will be \"the team\", and team2 will be \"the opponent\". For all other games, I pick a random number between 0 and 1. If it's greater than or equal to 0.5, team1 is \"the team\" and team2 is \"the opponent\". Otherwise, it's the reverse.\n\n```{r}\nfor (i in ids){\n  common <- eowResults %>% \n    filter(id == i) %>% \n    slice(1) %>% \n    select(id, week, year)\n  \n  team1 <- eowResults %>% \n    filter(id == i) %>% \n    slice(1) %>% \n    select(-id, -week, -year)\n  \n  colnames(team1) <- paste(colnames(team1), \"team\", sep = \"_\")\n  \n  team2 <- eowResults %>% \n    filter(id == i) %>% \n    slice(2) %>% \n    select(-id, -week, -year)\n  \n  colnames(team2) <- paste(colnames(team2), \"opponent\", sep = \"_\")\n  \n  if (i == min(ids)){df <- bind_cols(common, team1, team2)}\n  else{\n    ifelse(runif(1) >= 0.5, \n           newRow <- bind_cols(common, team1, team2), \n           newRow <- bind_cols(common, team2, team1))\n    df <- df %>% bind_rows(newRow)}\n  \n}\n```\n\n```{r include=FALSE}\nrm(cmeans, i, common, team1, team2)\n```\n\nLike I said, brute force. Now I have some redundant columns, so I'll drop drop them before going further.\n\n```{r}\ndf <- \n  df %>% \n  select(-homeAway_team, -homeAway_opponent, -neutral_site_team,\n         -neutral_site_opponent, -MOV_actual_opponent, -HFA_opponent,\n         -home_spread_opponent, -spread_opponent, -home_spread_team)\n```\n\nThe final big step is to add a bunch of new columns to represent the difference in one team's average performance versus the average performance of the other team. Think of it this way. If a team scores on average 30 points a game, you might think that's pretty good. However, if the teams they've played have on average given up 40 points, then that 30 points doesn't look as impressive. I want to account for that for a number of statistics, so that's what I do here.\n\n```{r}\ndf <- \n  df %>%\n  mutate(\n    diffPointsScored = offensePoints_team - defensePointsAllowed_opponent,\n    diffPointsAllowed = defensePointsAllowed_team - offensePoints_opponent,\n    diffYPPAOff = yardsPerPass_team - defenseYPPAAllowed_opponent,\n    diffYPPADef = defenseYPPAAllowed_team - yardsPerPass_opponent,\n    diffYPRAOff = yardsPerRushAttempt_team - defenseYPRAAllowed_opponent,\n    diffYPRADef = defenseYPRAAllowed_team - yardsPerRushAttempt_opponent,\n    diffPassYardsOff = netPassingYards_team - defensePassYardsAllowed_opponent,\n    diffPassYardsDef = defensePassYardsAllowed_team - netPassingYards_opponent,\n    diffRushYardsOff = rushingYards_team - defenseRushYardsAllowed_opponent,\n    diffRushYardsDef = defenseRushYardsAllowed_team - rushingYards_opponent,\n    diffYPPOff = yardsPerPlay_team - defenseYardsPerPlayAllowed_opponent,\n    diffYPPDef = defenseYardsPerPlayAllowed_team - yardsPerPlay_opponent,\n    diffELO = elo_team - elo_opponent,\n    diffWinPct = winPct_team - winPct_opponent\n  ) %>%\n  select(-elo_team, -elo_opponent, -winPct_team, -winPct_opponent)\n```\n\nAt this point, I noticed that there are a number of NAs in the `spread_team` column, and they're all from the 2020 season. I guess that might have to do with it being the first COVID season. I'll replace those NAs with 0s - again, maybe not the best idea if I was doing this for real.\n\n```{r}\ndf <- df %>% mutate(spread_team = replace_na(spread_team, 0))\n```\n\nOne last thing. This is going to seem out of place here, but since I cranked away at this data set a bunch of times as I was working through this, I developed some insights and some practices. First, I'll explicitly set the teams as factors instead of strings. I'll also generate a new column, `diffMOV` as the difference in the mean margin of victory - that turned out to be useful. I'll also get rid of any column with \"TD\" in it's name because I found them to be unhelpful. Same thing with pass completions, pass attempts (I essentially have those already in `passEfficiency`), and rushing attempts. Finally, I reorder columns to make looking at the dataset a little easier.\n\n```{r}\nlvls <- sort(unique(c(df %>% .$school_team, df %>% .$school_opponent)))\n\ndf <- df %>%\n  mutate(school_team = factor(school_team, levels = lvls),\n         school_opponent = factor(school_opponent, levels = lvls),\n         diffMOV  = MOV_team - MOV_opponent) %>%\n  select(\n    -MOV_team, -MOV_opponent,\n    -rushingTDs_team, -rushingTDs_opponent,\n    -puntReturnTDs_team, -puntReturnTDs_opponent,\n    -passingTDs_team, -passingTDs_opponent,\n    -kickReturnTDs_team, -kickReturnTDs_opponent,\n    -interceptionTDs_team, -interceptionTDs_opponent,\n    -passCompletions_team, -passCompletions_opponent,\n    -passAttempts_team, -passAttempts_opponent,\n    -rushingAttempts_team, -rushingAttempts_opponent\n  ) %>%\n  select(id, week, year, school_team, MOV_actual_team, HFA_team, spread_team, \n         school_opponent, diffELO, everything())\n```\n\nData wrangling is finally complete, and the data are now ready to be split into training and test data sets. The training data will be the 2017-2020 seasons (`df20`), and I'll train some models on that to predict the 2021 season (`df21`).\n\n```{r}\ndf20 <- df %>% filter(year < 2021) %>% select(-year)\ndf21 <- df %>% filter(year == 2021)\n```\n\nPause one more time and think about the data at this point. Recall that the df20 and df21 data are game **results**. I can't use game results in the test data set - I won't have results prior to each game being played! I will however have week 1 results available at the start of week 2, and both of those will be available at the start of week 3, and so on. If I group the test data by team and week, I can just shift all of the results data down one row. That will produce NAs for the first game each team plays, so I'll drop those. This means I won't have a prediction for the first game each team plays, either. I'll need to find another way of doing things if I want to do this for real. Forging ahead anyway for now...\n\n```{r}\ndf21 <-\n  df21 %>%  \n  arrange(school_team, week) %>% \n  group_by(school_team) %>% \n  mutate(across(9:102, lag)) %>%\n  ungroup() %>%\n  drop_na() %>% \n  select(-year)\n\nhead(df21)\n```\n\n## Feature Selection With Lasso Regression\n\nThat was a fair amount of work! We now have data sets with 102 columns, and I know that a decent amount of those columns are just noise. My go-to method for feature selection is lasso regression, and it happens to be the same techniques used by the authors. But wait! I've been a fan of the `caret` package to do modeling, but now there's [tidymodels](https://www.tidymodels.org/start/) - written with tidy concepts in mind. And written by Max Kuhn - the author of `caret`. I've been wanting to try this out, so here goes.\n\nAfter importing the library, I need to get my training and test sets back into one dataset so tidymodels can do its thing in its tidy way. I join them and the re-split them with `initial_time_split()` because my observations are by week and year. The proportion is 2682/3298 because the first 2682 observations are the games in the 2017-2020 seasons. I'll also create a validation data set.\n\n```{r}\nlibrary(tidymodels)\n\ndf_joined <- df20 %>% bind_rows(df21)\n\ndata_split <- initial_time_split(df_joined, prop = 2682/3298)\n\ntrain_data <- training(data_split)\ntest_data  <- testing(data_split)\n```\n\nI'm not going to go into detail here about what each of these steps are doing because I can't to it any better than [the docs](https://www.tidymodels.org/start/).\n\n```{r}\n# create the recipe\n# note I omit the categorical school variables\nlm_rec <-\n  recipe(MOV_actual_team ~ ., data = train_data %>% select(-id, -week, -school_team, -school_opponent)) %>% \n  step_dummy(all_nominal_predictors()) %>%        # one-hot encoding\n  step_zv(all_predictors()) %>%                   # eliminate zero variance columns\n  step_normalize(all_numeric(), -all_outcomes())  # normalize numeric variables\n\n# define the model and hyperparameters to tune\nlm_mod <-\n  linear_reg(penalty = tune(), mixture = 1) %>%\n  set_engine(\"glmnet\")\n\n# values to select when tuning\nlambda_grid <- tibble(penalty = 10^seq(-2, 1, length.out = 50))\n\n# cross validation folds\nset.seed(345)\nfolds <- vfold_cv(train_data, v = 10)\n\n# create the workflow\nlm_wflow <- \n  workflow() %>% \n  add_model(lm_mod) %>% \n  add_recipe(lm_rec)\n\n# tune the model\nlm_res <- \n  lm_wflow %>% \n  tune_grid(\n    grid = lambda_grid,\n    resamples = folds,\n    control = control_grid(save_pred = TRUE)\n  )\n```\n\nLet's take a look at the mean error and R-squared for the different penalty values (thanks to [this post](https://juliasilge.com/blog/lasso-the-office/) for the nice plot idea).\n\n```{r}\nlm_res %>%\n  collect_metrics() %>%\n  ggplot(aes(penalty, mean, color = .metric)) +\n  geom_errorbar(aes(\n    ymin = mean - std_err,\n    ymax = mean + std_err\n  ),\n  alpha = 0.5\n  ) +\n  geom_line(size = 1.5) +\n  facet_wrap(~.metric, scales = \"free\", nrow = 2) +\n  scale_x_log10() +\n  theme_bw() +\n  theme(legend.position = \"none\")\n```\n\nI have some choices of what do to next. Normally, what I'd do is select the simplest model within one standard error of the model with the lowest RMSE. I can do that with the `select_by_one_std_err()` function as shown below. Note the penalty value for that model and hold that thought.\n\n```{r}\nlm_res %>% select_by_one_std_err(metric = \"rmse\", desc(penalty))\n```\n\nI could also forget the \"within one standard error\" aspect and just select the model with the lowest RMSE (or I could select the least complex model that has no more than a certain percentage loss of RMSE). Select the model with the lowest error gives the folloing penalty value. Which one shoud I choose?\n\n```{r}\nlowest_rmse <- lm_res %>% select_best(\"rmse\")\nlowest_rmse\n```\n\nTake a look at the model object below. If I go with the 1SE lambda of 1.6, based on the degrees of freedom (Df) I'll have only 2 or 3 predictors in the model (1.64 just happens to fall between the two penalty values below, so I'm not sure how many predictor will actually be selected). So out of about 100 predictors, only 2 or three will be selected. To me, that means a few variables dominate and the rest are just noise. With the lowest RMSE lambda value of 0.256, there will be 21-22 predictors selected. For the purpose of this post, I'm going to choose the lowest RMSE.\n\nFor the final fit, I finalize the work flow based on the lowest RMSE. Notice I also use `data_split`, which contains both the training and test data. From that fit, I get the RMSE and R-squared for the test data set. The RMSE is about 3 touchdowns, and the R-squared is alarmingly low.\n\n```{r}\nlm_final_wf <- \n  lm_wflow %>% \n  finalize_workflow(lowest_rmse)\n\nlm_final_fit <- \n  lm_final_wf %>%\n  last_fit(data_split) \n\nlm_final_fit %>% collect_metrics()\n```\n\n```{r}\nlm_final_fit %>% \n  extract_fit_parsnip()\n```\n\nHere I plot the selected predictors color coded by whether the coefficient is positive or negative. Clearly, `diffMOV` dominates all other variables. Other important variables include the spread and home field advantage. Everything after that is probably just noise.\n\n```{r}\nlm_final_fit %>% \n  extract_fit_parsnip() %>%\n  vip::vi(lambda = lowest_rmse$penalty) %>%\n  mutate(\n    Importance = abs(Importance),\n    Variable = forcats::fct_reorder(Variable, Importance)\n  ) %>%\n  filter(Importance != 0) %>%\n  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +\n  geom_col() +\n  scale_x_continuous(expand = c(0, 0)) +\n  labs(y = NULL) +\n  theme_bw()\n```\n\nWell, what if we were to make predictions based off of this model? First I'll make a scatter plot of predictions versus actual MOV.\n\n```{r}\nlm_final_fit %>% \n  collect_predictions() %>%\n  ggplot() +\n  geom_abline(intercept = 0, slope = 1, color = \"red\") +\n  geom_point(aes(x=`.pred`, y=MOV_actual_team)) +\n  theme_bw() +\n  labs(title = \"Linear Model Prediction Results\",\n       x = \"Predicted MOV\",\n       y = \"Actual MOV\")\n```\n\nNThere's a little bit of a trend there, but it looks more like a shotgun blast. Not surprising, though, given the RMSE and R-squared we saw earlier. Let's see what percent of predictions were correct in a head-to-head sense - in other words, what percent predicted just the correct winner.\n\n```{r}\nlm_final_fit %>% \n  collect_predictions() %>%\n  mutate(both_positive = `.pred` > 0 & MOV_actual_team > 0,\n         both_negative = `.pred` < 0 & MOV_actual_team < 0,\n         correct = both_positive + both_negative) %>% \n  summarize(sumCorrect = sum(correct)) / nrow(df21)\n```\n\nHmm... 64% Better than half, anyway, but not very impressive. Before I move on to another model type, I'll grab the 22 predictors so I can remove everything else from the training and test data sets.\n\n```{r}\nkeep_vars <- \n  lm_final_fit %>% \n  extract_fit_parsnip() %>%\n  vip::vi(lambda = lowest_rmse$penalty) %>%\n  filter(Importance != 0) %>%\n  .$ Variable\n```\n\n## Random Forest Model\n\nI'll try a few different models with the same data and see how they compare. I'll start with a random forest model using the `ranger package`. I'll use the same tidymodels procedure as above: create a recipe, model, and workflow, tune hyperparameters, and show the errors for the best model. This takes a while to execute on my laptop even when using all available cores.\n\n```{r}\ncores <- parallel::detectCores()\n\n# the recipe\nrf_rec <- \n  recipe(MOV_actual_team ~ ., data = train_data %>% select(keep_vars, MOV_actual_team)) %>% \n  step_dummy(all_nominal_predictors()) %>% \n  step_zv(all_predictors())\n\n# the model to tune\nrf_mod <-\n  rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>%\n  set_engine(\"ranger\", importance = \"impurity\", num.threads = cores) %>%\n  set_mode(\"regression\")\n\n# the workflow\nrf_wflow <- \n  workflow() %>% \n  add_model(rf_mod) %>% \n  add_recipe(rf_rec)\n\n# now set the seed for reproducability and tune the hyperparameters\nset.seed(1234)\n\nrf_fit <-\n  rf_wflow %>%\n  tune_grid(grid = 25,\n            control = control_grid(),\n            resamples = folds)\n\n# take a look at the best models\nrf_fit %>% show_best(metric = \"rmse\")\n```\n\nThere's a nice `autoplot()` function that comes with `tune` (one of the tidymodels dependencies) that can be used with various tidymodels objects. Let's check it out with `rf_fit`.\n\n```{r}\nautoplot(rf_fit) + theme_bw()\n```\n\nLooks like large numbers of `mtry` are good, but the error flattens out after 50 or so.\n\n```{r}\n# final fit\nlast_rf_mod <- \n  rand_forest(mtry = 17, min_n = 22, trees = 1000) %>% # original \n  set_engine(\"ranger\", importance = \"impurity\", num.threads = cores) %>% \n  set_mode(\"regression\")\n\n# the last workflow\nlast_rf_workflow <- \n  rf_wflow %>% \n  update_model(last_rf_mod)\n\n# the last fit\nset.seed(345)\nlast_rf_fit <- \n  last_rf_workflow %>% \n  last_fit(data_split)\n\nlast_rf_fit %>% collect_metrics()\n```\n\nStill pretty bad. Let's take a look at variable importance for this model.\n\n```{r}\nlast_rf_fit %>% \n  pluck(\".workflow\", 1) %>%   \n  extract_fit_parsnip() %>% \n  vip::vip(num_features = 22) +\n  theme_bw()\n```\n\nReally only three variables that are contributing much to the model. I'll do predicted versus actual again and hope for less of a shotgun blast.\n\n```{r}\nlast_rf_fit %>% \n  collect_predictions() %>%\n  ggplot() +\n  geom_abline(intercept = 0, slope = 1, color = \"red\") +\n  geom_point(aes(x=`.pred`, y=MOV_actual_team)) +\n  theme_bw() +\n  labs(title = \"Ranger Prediction Results\",\n       x = \"Predicted MOV\",\n       y = \"Actual MOV\")\n```\n\nMaybe looks a little more elongated but that could be wishful thinking. How about the percent correct head to head?\n\n```{r}\nlast_rf_fit %>% \n  collect_predictions() %>%\n  mutate(both_positive = `.pred` > 0 & MOV_actual_team > 0,\n         both_negative = `.pred` < 0 & MOV_actual_team < 0,\n         correct = both_positive + both_negative) %>%\n  summarize(sumCorrect = sum(correct)) / nrow(df21)\n```\n\nSlightly worse, but basically the same. Well, while I'm at it, I'll look at predictions, actual MOV, and the spread.\n\n```{r}\nlast_rf_fit %>% \n  collect_predictions() %>%\n  mutate(spread_team = test_data$spread_team) %>%\n  select(`.pred`, MOV_actual_team, spread_team) %>%\n  head()\n```\n\nThe predictions don't compare well, that's for sure. Well, this may partially be the result of replacing NAs with 0s earlier, and I suspect I just have too many garbage predictors in the model. The authors were getting a head to head accuracy in the low 70's, so there's definite room for improvement. I'll drive on anyway and look at teams that did a lot better or worse than predicted. Here I show only the extreme two ends. I plot (predicted - actual), so positive values are for teams that I predicted would win by a much larger margin than they actually did.\n\n```{r}\n#| fig.height: 8\n\nlast_rf_fit %>% \n  collect_predictions() %>%\n  mutate(team = df21$school_team,\n         opp = df21$school_opponent,\n         spread_team = df21$spread_team) %>%\n  group_by(team) %>%\n  summarize(meanDiff = mean(`.pred` - MOV_actual_team)) %>%\n  arrange(meanDiff) %>%\n  mutate(team = forcats::fct_reorder(team, meanDiff)) %>%\n  filter(abs(meanDiff) > 7) %>%\n  ggplot() +\n  geom_col(aes(x=team, y=meanDiff)) +\n  coord_flip() +\n  theme_bw()\n```\n\nFinally, I'll look at the proportion of games I correctly predicted over time. I'm curious if I do poorly early in the season and then improve, or if it's relatively consistent. Quick note: the first time I made this plot, I was getting 100% accuracy in the early weeks, and then it got steadily worse over time. That was a giant red flag, and after thoroughly scrubbing my code, I found an error where some actual results had snuck into the test data. I'm glad I caught that!\n\n```{r}\nlast_rf_fit %>%\n  collect_predictions() %>%\n  bind_cols(test_data %>% \n              select(id, week, school_team, school_opponent) %>% \n              rename(\"ID\" = \"id\")) %>%\n  mutate(incorrect = case_when(\n    `.pred` > 0 & MOV_actual_team < 0 ~ 1,\n    `.pred` < 0 & MOV_actual_team > 0 ~ 1,\n    TRUE ~ 0), \n    correct= case_when(\n      `.pred` > 0 & MOV_actual_team > 0 ~ 1,\n      `.pred` < 0 & MOV_actual_team < 0 ~ 1,\n      TRUE ~ 0)) %>%\n  group_by(week) %>%\n  summarize(sumIncorrect = sum(incorrect),\n            sumCorrect = sum(correct),\n            n = n(),\n            proportionCorrect = sumCorrect / n) %>%\n  ggplot() +\n  geom_col(aes(x=week, y=proportionCorrect)) +\n  theme_bw()\n```\n\nLooks reasonably consistent, so at least I know I fixed that error.\n\n## Gradient Boost Machine Model\n\nI don't have much hope that this will be any better than the last two models, but it'll give me another rep with the tidymodels workflow. Note that I'm using the random forest recipe (`rf_rec`). In hindsight, the recipe is model agnostic, so I should have just called it something generic to avoid confusion.\n\n```{r}\nset.seed(345)\ngbm_mod <-\n  boost_tree(trees = 1000, \n             tree_depth = tune(), \n             min_n = tune(), \n             loss_reduction = tune(),\n             sample_size = tune(), \n             mtry = tune(),\n             learn_rate = tune()) %>%\n  set_engine(\"xgboost\", num.threads = cores) %>%\n  set_mode(\"regression\")\n\ngbm_wflow <- \n  workflow() %>% \n  add_model(gbm_mod) %>% \n  add_recipe(rf_rec)\n\ngbm_fit <- \n  gbm_wflow %>% \n  tune_grid(grid = 25,\n            control = control_grid(save_pred = TRUE),\n            resamples = folds)\n\ngbm_fit %>% show_best(metric = \"rmse\")\n```\n\nThen the final fit.\n\n```{r}\ngbm_best <- \n  gbm_fit %>% \n  select_best(metric = \"rmse\")\n\n# final fit\nlast_gbm_mod <- \n  boost_tree(trees = 1000, \n              tree_depth = gbm_best %>% .$tree_depth, \n              min_n = gbm_best %>% .$min_n, \n              loss_reduction = gbm_best %>% .$loss_reduction,\n              sample_size = gbm_best %>% .$sample_size, \n              mtry = gbm_best %>% .$mtry,\n              learn_rate = gbm_best %>% .$learn_rate) %>% \n  set_engine(\"xgboost\", num.threads = cores) %>% \n  set_mode(\"regression\")\n\n# the last workflow\nlast_gbm_workflow <- \n  gbm_wflow %>% \n  update_model(last_gbm_mod)\n\n# the last fit\nset.seed(345)\nlast_gbm_fit <- \n  last_gbm_workflow %>% \n  last_fit(data_split)\n\n# since I used data_split above, this includes the test data set\nlast_gbm_fit %>% collect_metrics()\n```\n\nMore of the same, of course, and now variable importance.\n\n```{r}\nlast_gbm_fit %>% \n  pluck(\".workflow\", 1) %>%   \n  extract_fit_parsnip() %>% \n  vip::vip(num_features = 20) +\n  theme_bw()\n```\n\nYep, and now accuracy.\n\n```{r}\nlast_gbm_fit %>% \n  collect_predictions() %>%\n  mutate(both_positive = `.pred` > 0 & MOV_actual_team > 0,\n         both_negative = `.pred` < 0 & MOV_actual_team < 0,\n         correct = both_positive + both_negative) %>%\n  summarize(sumCorrect = sum(correct)) / nrow(df21)\n```\n\nAbout the same as the others, so no surprise. Well, aside from demonstrating the garbage-in garbage-out principle, it was interesting to dip my toe in the waters of predictive modeling of sports events. As a bonus, I got some practice with tidymodels, which was great.\n\nAt this point in my weekend modeling, I paused and thought about what might have gone wrong and what might have gone right in the methodology I used. I also read [this post](https://blog.collegefootballdata.com/talking-tech-building-an-artifical-neural-network-to/) about using a neural net to predict college football games. I tend to shy away from neural nets for regression problems. In my experience, they're a pain to set up, take a long time to train, and I really haven't seen them outperform the simpler, faster, and interpretable tree-based models.\n\nThen I stumbled across [this blog post from RStudio](https://blogs.rstudio.com/ai/posts/2021-02-11-tabnet/) that demonstrated the use of `tabnet`, a neural net model developed by Google specifically for tabular data that incorporates some of the processes in tree-based models to improve interpretability. In the [original paper](https://arxiv.org/abs/1908.07442), the authors also demonstrated that `tabnet` was on par, and often better, than the current go-to models like `xgboost`. So, time to give it a whack.\n\n## Neural Net Model\n\nAs I mentioned, I'm not too happy with the mess of predictors I've been using so far. Time for a fresh start using just a few predictors similar to the CollegeFootballData.com blog I just mentioned. I have lots of variables in my environment right now, so first I'm going to purge.\n\n```{r}\nrm(list = ls())\n```\n\nI'll load some of the same data sets from disk that I used earlier and filter non-FBS games as before. However, this time, I'm only going to keep a few columns: id, school, conference, homeAway, points, week, and year.\n\n```{r}\ngs <- readRDS(\"gameStats_full.RData\")\ngs <- type.convert(gs, as.is = TRUE)\n\n# get the ID of non-FBS games\nfbs <- readRDS(\"fbs_teams.RData\")\nfcsIDs <- gs %>% filter(!school %in% (fbs %>% .$school)) %>% .$id\n\n# filter\ngs <- \n  gs %>%\n  filter(!id %in% fcsIDs) %>%\n  select(id, school, conference, homeAway, points, week, year)\n```\n\nI'll create home and away dataframes again as earlier and add the Elo and neutral site data, and then recombine it all into a dataframe called `pregame`. I'll calculate the margin of victory (mov) here, too. I noticed one of the away conference names was missing but was able to track down that it was a FBS independent team.\n\n```{r}\nhome <- gs %>% filter(homeAway == \"home\")\naway <- gs %>% filter(homeAway == \"away\")\n\n# get pre-game Elo and neutral vield data\neloSite <- readRDS(\"eloSite.RData\") %>% \n  filter(!id %in% (fcsIDs)) %>% \n  tidyjson::as_tibble(eloSite)\n\n# get pre-game spread\nspread <- readRDS(\"spread.RData\")\nspread <- spread %>% filter(!id %in% (fcsIDs))\nspread <- spread %>% drop_na()\n\npregame <- spread %>% left_join(eloSite, by = \"id\")\n\npregame <- \n  pregame %>%\n  left_join(home %>% select(-school, -homeAway), by = \"id\") %>%\n  rename(\"home_conference\" = \"conference\", \"home_points\" = \"points\") %>%\n  left_join(away %>% select(-school, -year, -homeAway, -week), by = \"id\") %>%\n  rename(\"away_conference\" = \"conference\", \"away_points\" = \"points\") %>% \n  mutate(mov = home_points - away_points) %>%\n  select(-home_points, -away_points) %>% \n  arrange(year) %>%\n  mutate(away_conference = replace_na(away_conference, \"FBS Independents\"))\n\nhead(pregame)\n```\n\nI'm only working with 12 columns this time - well, 9 if you don't count id, week, and year. I won't use those for training or testing. They're just to keep track of things. So it's down to team, conference, spread, Elo, and the home field advantage thing, which I'll address next.\n\nRecall my first attempt was complicated and involved looping over game IDs. I came up with a much better way this time. I randomly select game IDs, then apply the HFA indicator in place. Way faster and a lot clearer what I'm doing.\n\n```{r}\nset.seed(42)\nidx <- sample(1:nrow(pregame), trunc(nrow(pregame) / 2))\npregame$HFA <- 0\npregame[idx, \"HFA\"] <- 1\npregame[-idx, \"HFA\"] <- -1\npregame[-idx, \"mov\"] <- pregame[-idx, \"mov\"]\npregame <- pregame %>% mutate(HFA = ifelse(neutral_site, 0, HFA))\n```\n\nThe last thing to do is turn the team names into factors.\n\n```{r}\npregame <-\n  pregame %>%\n  mutate(home_team = factor(home_team),\n         away_team = factor(away_team))\n```\n\nThat's it! I'm ready to split the data in the training, test, and validation sets and get to model building.\n\n```{r}\ndata_split <- \n  initial_time_split(\n    pregame %>% select(-id, -year, -neutral_site, -week),\n    prop = 2656/3391)\n\ntrain_data <- training(data_split)\ntest_data  <- testing(data_split)\nset.seed(234)\nval_set <- validation_split(train_data, prop = 0.80)\n```\n\nThere are many hyperparameters to tune, and I'll exclude epochs, batch_size, and virtual_batch_size just to speed this part up.\n\n```{r message=FALSE, warning=FALSE}\nlibrary(tabnet)\n\nnn_rec <- recipe(mov ~ ., train_data) %>%\n  step_normalize(all_numeric(), -all_outcomes())\n\nnn_mod <-\n  tabnet(epochs = 5, \n         batch_size = 256, \n         decision_width = tune(), \n         attention_width = tune(),\n         num_steps = tune(), \n         penalty = tune(), \n         virtual_batch_size = 64, \n         momentum = tune(),\n         feature_reusage = tune(), \n         learn_rate = tune()\n  ) %>%\n  set_engine(\"torch\") %>%\n  set_mode(\"regression\")\n\nnn_wf <- \n  workflow() %>%\n  add_model(nn_mod) %>%\n  add_recipe(nn_rec)\n\nset.seed(42)\nnn_fit <-\n  nn_wf %>%\n  tune_grid(val_set,\n            grid = 50,\n            control = control_grid())\n\nnn_fit$.notes[[1]]$note\n\nnn_fit %>% show_best(metric = \"rmse\")\n```\n\nThe final fit.\n\n```{r}\n# with tuned parameters\nlast_nn_mod <-\n  tabnet(epochs = 15, \n         batch_size = 256, \n         decision_width = 15, \n         attention_width = 62,\n         num_steps = 8, \n         penalty = 0.1430669, \n         virtual_batch_size = 64, \n         momentum = 0.194,\n         feature_reusage = 1.148, \n         learn_rate = 0.02395\n  ) %>%\n  set_engine(\"torch\", verbose = TRUE) %>%\n  set_mode(\"regression\")\n\n# the last workflow\nlast_nn_workflow <- \n  nn_wf %>% \n  update_model(last_nn_mod)\n\n# the last fit\nset.seed(42)\nlast_nn_fit <- \n  last_nn_workflow %>% \n  last_fit(data_split)\n\n# since I used data_split above, this includes the test data set\nlast_nn_fit %>% collect_metrics()\n```\n\nBoth metrics are quite a bit higher than what we've seen up to this point, so I'm optimistic this model will perform better.\n\n```{r}\nlast_nn_fit %>% \n  pluck(\".workflow\", 1) %>%   \n  extract_fit_parsnip() %>% \n  vip::vip() +\n  theme_bw()\n```\n\nThe model relies heavily on the spread, which makes sense since given that it's hard to beat the spread, and I'm considering only a few other predictors.\n\n```{r}\n# find percent I predicted the correct winner\nlast_nn_fit %>% \n  collect_predictions() %>%\n  mutate(both_positive = `.pred` > 0 & mov > 0,\n         both_negative = `.pred` < 0 & mov < 0,\n         correct = both_positive + both_negative) %>%\n  summarize(Correct = sum(correct)) / nrow(test_data)\n```\n\nThis model correctly predicts 72.3% of the game winners, compared to the \\~ 60% for the earlier models. How does that compare to the spread?\n\n```{r}\n# how does the spread do?\nlast_nn_fit %>% \n  collect_predictions() %>%\n  mutate(spread = -test_data$home_spread,\n         both_positive = spread > 0 & mov > 0,\n         both_negative = spread < 0 & mov < 0,\n         correct = both_positive + both_negative) %>%\n  summarize(Correct = sum(correct)) / nrow(test_data)\n```\n\nNot surprising that it's almost the same. Really at this point, this model basically *is* the spread. Obviously, if we want to beat the spread, we need to improve on this. Let's check the predicted vs. actual raw values.\n\n```{r}\nlast_nn_fit %>% \n  collect_predictions() %>%\n  head(10)\n```\n\nAnd now let's plot them.\n\n```{r}\nlast_nn_fit %>% \n  collect_predictions() %>%\n  ggplot() +\n  geom_abline(intercept = 0, slope = 1, color = \"red\") +\n  geom_point(aes(x=`.pred`, y=mov)) +\n  theme_bw() +\n  labs(title = \"NN Prediction Results\",\n       x = \"Predicted MOV\",\n       y = \"Actual MOV\")\n```\n\n### Interpretability Plots\n\nEarlier I mentioned that `tabnet` models were developed to be interpretable. The following plot shows the first 50 games in the test set with games on the x axis. For these games, it seems the Elo scores were the biggest contributors. Interesting. I wonder why we don't see more of an impact from the spread.\n\n```{r}\nexp_fit <- \n  last_nn_fit %>% \n  pluck(\".workflow\", 1) %>%   \n  extract_fit_parsnip()\n\nex_fit <- tabnet_explain(exp_fit$fit, test_data[1:50, ])\n\nautoplot(ex_fit) +\n  labs(x = \"Game\", y = \"Predictor\")\n```\n\nNext, for the same 50 games, we see that different predictors are important in different steps. Here we see that spread comes into play mostly in the 7th and 8th step.\n\n```{r}\n# PER-STEP, OBSERVATION-LEVEL FEATURE IMPORTANCES\nautoplot(ex_fit, type=\"steps\") +\n  labs(x = \"Game\", y = \"Predictor\")\n```\n\n## Next Steps\n\nWhile `tabnet` looks promising, I can't directly compare its performance with the other models in this post because I used a different data set for it. I saw in the tidymodels docs that there's a way to do model comparison using work flow sets, so I'll check that out in another post.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Predictive Modeling","description":"A variety of machine learning models to predict beating the spread.","author":"John King","date":"3/12/2022","categories":["R","ggplot2","college football","sports analytics","machine learning"],"image":"teaser.png","code-copy":true},"extensions":{"book":{"multiFile":true}}}}}