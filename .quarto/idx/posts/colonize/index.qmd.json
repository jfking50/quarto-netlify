{"title":"Space Colonization","markdown":{"yaml":{"title":"Space Colonization","description":"Organic looking life forms from math.","author":"John King","date":"5/8/2022","format":{"html":{"toc":true,"code-fold":false,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"message":false,"echo":true},"categories":["R","ggplot2","generative art"],"image":"teaser.png"},"headingText":"Space Colonization Algorithm","containsRefs":false,"markdown":"\n\nContinuing the series of generative art posts, I liked the look of the `canvas_petri()` images from [the aRtsy package](https://github.com/koenderks/aRtsy). That led me to [this article](https://medium.com/@jason.webb/space-colonization-algorithm-in-javascript-6f683b743dc5) that describes the algorithm behind the `canvas_petri()` in enough detail that I thought I could give it a shot.\n\n\nTurns out the images are generated using something called the space colonization algorithm. When I first read that, this kind of space colonization came to mind.\n\n![via GIPHY](https://media.giphy.com/media/l0HlFmziO9XfPR2ta/giphy.gif){fig-align=\"center\"}\n\nThat's not it, though. They mean colonizing the space inside of, say, a circle. Borrowing an image from the article above, we're looking for something more like this.\n\n![Image from Jason Webb article above.](https://miro.medium.com/max/1400/1*5oi65XbU2A-C__JFf7E1kg.png)\n\nJason's article does a good job describing the algorithm and shows images to visualize the process, so I'll just paraphrase. It goes like this:\n\n1.  Randomly place points in some sort of bounding shape (rectangle, circle, etc.). These are called \"attractors\".\n2.  Place one or more \"nodes\" in the same shape. These will serve as the starting points for the vein-like lines in the above image. In the image above, there's just one starting node in the middle right.\n3.  For every attractor, find the node closest to it. If you start with one \"seed\" node, of course there's only one node to choose from. We'll add nodes in a later step, so this gets more complicated as we progress.\n4.  Find the coordinates of the centroid of the attractors closest to each node.\n5.  Add another node some distance away from the original node in the direction of the centroid.\n6.  Now consider a radius around each attractor - Jason called that area the kill zone. If any new nodes are within an attractor's kill zone, delete the attractor.\n7.  Continue this process until all attractors have been deleted.\n8.  Visualize by plotting lines between all of the nodes.\n\nSeems relatively straight forward, so let's do it step by step.\n\n### Place Attractors\n\nI'll place 50 attractors in a 10 x 10 square.\n\n```{r}\nlibrary(dplyr)\nlibrary(ggplot2)\n\nset.seed(1)\natt <- data.frame(x = runif(50, 0, 10), y = runif(50, 0, 10))\n\nhead(att)\n```\n\n### Place A Node\n\nEasy enough. I'll just put it in the center of the square. I'm adding a couple other columns to this data frame. `n` will keep track of the node numbers, and `s` will be used to keep track of line segments.\n\n```{r}\nnodes <- data.frame(n = 1, x=5, y=5, s=1)\n```\n\n### Find The Closest Nodes\n\nAgain, finding the closest node to each attractor is trivial when there's only one node, but it will get more complicated as we add nodes. First, though, as I was working through this script, I found that sometimes at this step attractors are aready within the kill zone, so let's check for that and delete them if needed.\n\n```{r}\nkill_distance <- 0.25\n\natt <- att[sapply(1:nrow(att), \n                  function(x) \n                    min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)) > kill_distance), ]\n\nnrow(att)\n```\n\nNot this time, but we'll re-use this bit of code after adding new nodes. I'm going to add a new column `cl` to record the closest node number to each attractor.\n\n```{r}\natt$cl <- sapply(1:nrow(att), \n                 function(x) \n                   nodes[which.min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)), \"n\"])\n\nhead(att)\n```\n\n### Centroids\n\nSince node 1 is the closest to all attractors, there's only one centroid to find. `mx` is the mean x coordinate, and `my` is the mean y coordinate. We also need the angle, `theta` from the node to the centroid.\n\n```{r}\n# get each centroid coords\nns <- unique(att$cl)\nmx <- sapply(ns, function(x)mean(att[att$cl==x, \"x\"]))\nmy <- sapply(ns, function(x)mean(att[att$cl==x, \"y\"]))\n\n# get the angle from the nodes to the centroids\nthetas <- sapply(\n  1:length(ns), \n  function(x)\n    ifelse(mx[x] > nodes[nodes$n==ns[x], \"x\"],\n           atan((my[x] - nodes[nodes$n==ns[x], \"y\"]) / (mx[x] - nodes[nodes$n==ns[x], \"x\"])),\n           pi + atan((my[x] - nodes[nodes$n==ns[x], \"y\"]) / (mx[x] - nodes[nodes$n==ns[x], \"x\"])))\n)\n\nprint(round(c(mx, my, thetas), 2))\n```\n\n### Add New Nodes\n\nI initialize the line segment counter I mentioned earlier. This is just to keep track of the segments for plotting purposes. I store the values in the `s` column. `newx` and `newy` are the coordinates for each new node. I store each new node along with the line segment information in a data frame called `new_n`, and then combine it with the `nodes` data frame. While I'm at it, I delete an attractor if a new node is within its kill zone. We should now have three rows in `nodes`: the original node associated with segment 1, and the original node and new node associated with segment 2.\n\n```{r}\nseq_count <- 1 # sequence counter\nseg_len <- 0.1 # the length of the line segment to a new node\n\nfor (i in 1:length(ns)){\n  \n  seq_count <- seq_count + 1\n  \n  newx <- seg_len * cos(thetas[i]) + nodes[nodes$n==ns[i], 'x']\n  newy <- seg_len * sin(thetas[i]) + nodes[nodes$n==ns[i], 'y']\n  \n  new_n <- data.frame(n = 1:2 + max(nodes$n),\n                      x=c(nodes[nodes$n==ns[i], 'x'], newx),\n                      y=c(nodes[nodes$n==ns[i], 'y'], newy),\n                      s=rep(seq_count, 2)\n                      )\n  \n  nodes <- rbind(nodes, new_n)\n  \n  # check if the node is within kill distance of an attractor\n  att <- att[sapply(1:nrow(att), \n                    function(x) \n                      min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)) > kill_distance), ]\n}\n\nnodes\n```\n\nLet's plot it to see what we have so far. The red line connects the nodes, and the attractors are dark green.\n\n```{r}\nggplot() +\n  geom_path(data=nodes, aes(x=x, y=y, group=s), \n            color=\"red\", size=2, lineend=\"round\") +\n  geom_point(data=att, aes(x=x, y=y), \n             color=\"darkgreen\", size=2) +\n  coord_fixed() +\n  theme_bw() +\n  theme(legend.position=\"none\")\n```\n\nNow it's just a matter of grinding through it until we finish deleting the nodes. Before we do that, let's put all that code into a `get_colony()` function because we're going to want to mess around with the different values we set earlier. We'll want to pass different shapes and arrangements of attractors, specify the seed, number of attractors, the kill zone, line segment length, and the coordinates of the first node (the trunk). The only thing new in the code below is the `while` loop, which checks for an empty `att` dataframe - our stopping condition for when all of the attractors have been deleted\n\n```{r}\nget_colony <- \n  function(att, seed=1, kill_distance=0.25, segment_length=0.1, trunk_x=0, trunk_y=0){\n\n  set.seed(seed)\n  \n  # where the colony starts from\n  nodes <- data.frame(n = 1, x=trunk_x, y=trunk_y, s=1)\n  \n  # delete attractors that are already within kill distance\n  att <- \n    att[sapply(1:nrow(att), \n               function(x) \n                 min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)) > kill_distance), ]\n  \n  seq_count <- 1\n  seg_len <- segment_length\n  \n  while (nrow(att) > 0){\n    # id the closest node to each attractor\n    att$cl <- \n      sapply(1:nrow(att), \n             function(x) \n               nodes[which.min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)), \"n\"])\n    \n    # get each centroid coords\n    ns <- unique(att$cl)\n    mx <- sapply(ns, function(x)mean(att[att$cl==x, \"x\"]))\n    my <- sapply(ns, function(x)mean(att[att$cl==x, \"y\"]))\n    \n    # get the angle from the nodes to the centroids\n    thetas <- sapply(\n      1:length(ns), \n      function(x)\n        ifelse(mx[x] > nodes[nodes$n==ns[x], \"x\"],\n               atan((my[x] - nodes[nodes$n==ns[x], \"y\"]) / (mx[x] - nodes[nodes$n==ns[x], \"x\"])),\n               pi + atan((my[x] - nodes[nodes$n==ns[x], \"y\"]) / (mx[x] - nodes[nodes$n==ns[x], \"x\"])))\n    )\n    \n    \n    # add a new segment in that direction\n    for (i in 1:length(ns)){\n      seq_count <- seq_count + 1\n      newx <- seg_len * cos(thetas[i]) + nodes[nodes$n==ns[i], 'x']\n      newy <- seg_len * sin(thetas[i]) + nodes[nodes$n==ns[i], 'y']\n      new_n <- data.frame(n = 1:2 + max(nodes$n),\n                          x=c(nodes[nodes$n==ns[i], 'x'], newx),\n                          y=c(nodes[nodes$n==ns[i], 'y'], newy),\n                          s=rep(seq_count, 2)\n      )\n      nodes <- rbind(nodes, new_n)\n      # check if the node is within kill distance of an attractor\n      att <- \n        att[sapply(1:nrow(att), \n                   function(x) \n                     min(sqrt((att[x, ]$x - nodes$x)^2 + (att[x, ]$y - nodes$y)^2)) > kill_distance), ]\n      \n      if (nrow(att) < 1) break\n    }\n  }\n  nodes\n}\n```\n\n## Visualizations\n\nLet's finish what we started. Here I call the function with the same parameters as earlier, and the function returns a data frame with all of the nodes for plotting.\n\n```{r}\ndf <- \n  get_colony(att, kill_distance=0.25, segment_length=0.1, trunk_x=5, trunk_y=5)\n\nhead(df)\n```\n\nAnd here it is.\n\n```{r}\nggplot() +\n  geom_path(data=df, aes(x=x, y=y, group=s), \n            color=\"red\", size=2, lineend=\"round\") +\n  geom_point(data=att, aes(x=x, y=y), \n             color=\"darkgreen\", size=2) +\n  coord_fixed() +\n  theme_bw() +\n  theme(legend.position=\"none\")\n```\n\nPretty weird looking, right? We can make a more interesting image by adding more attractors (500!), plotting only the line segments, and adding some varying thickness to the lines.\n\n```{r}\nset.seed(1)\natt <- data.frame(x = runif(500, 0, 10), y = runif(500, 0, 10))\n\ndf <- \n  get_colony(att, kill_distance=0.25, segment_length=0.1, trunk_x=5, trunk_y=5)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\n### Circles\n\nThat's a little better. It's getting that organic feel to it, I think. Let's try a bounding circle instead of a square. We'll put the starting seed in the middle of the circle at (0, 0).\n\n```{r}\nset.seed(1)\n# put all the attractors in a circle\na <- runif(500) * 2 * pi\nr <- 5 * sqrt(runif(500))\natt <- data.frame(x = r*cos(a), y = r*sin(a))\n\ndf <- \n  get_colony(att, kill_distance=0.25, segment_length=0.1, trunk_x=0, trunk_y=0)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\nHow about moving the starting node to the right?\n\n```{r}\ndf <- \n  get_colony(att, kill_distance=0.25, segment_length=0.1, trunk_x=4.5, trunk_y=0)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\n### Trees\n\nSeeing the image above made me think of a sideways bush, and then it occurred to me that I can make a tree-like image by placing the starting node below the bounding circle. While I'm at it, I'll plot the attractors as green circles like I did earlier to give a leaf-like effect.\n\n```{r}\ndf <- \n  get_colony(att, kill_distance=0.25, segment_length=0.1, trunk_x=0, trunk_y=-8)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  geom_point(data=att, aes(x=x, y=y), \n             color=\"darkgreen\", size=2) +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\nWe could continue by exploring different bounding shapes, color combinations, and adjusting all of the function parameters to make a variety of shapes.\n\n```{r}\na <- runif(250) * pi\nr <- 5 * sqrt(runif(250, 0.9, 1.0))\natt <- data.frame(x = r*cos(a), y = r*sin(a))\n\ndf <- \n  get_colony(seed=2, att, kill_distance=0.05, segment_length=0.01, trunk_x=0, trunk_y=-0.02)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  geom_point(data=att, aes(x=x, y=y), \n             color=\"darkgreen\", size=2) +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\n```{r}\na <- runif(250) * pi\nr <- 5 * sqrt(runif(250))\natt <- data.frame(x = r*cos(a), y = r*sin(a))\n\ndf <- \n  get_colony(seed=2, att, kill_distance=0.25, segment_length=0.1, trunk_x=0, trunk_y=-4)\n\nggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  geom_point(data=att, aes(x=x, y=y), \n             color=\"darkgreen\", size=2) +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\")\n```\n\n### Animated Tree\n\nOne last idea. Let's animate the tree \"growing\"!\n\n```{r}\n#| include: false\nlibrary(gganimate)\n\ndf %>% \n  ggplot() +\n  geom_path(data=df, \n            aes(x=x, y=y, group=s, size=1/s), \n            color=\"black\", lineend=\"round\") +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position=\"none\") +\n  transition_reveal(s)\n```\n\n![](tree.gif){fig-align=\"center\"}\n\nYou can [click here](https://cxxidemo.shinyapps.io/genart/) for my Shiny app to generate your own art using this and other algorithms. Enjoy!\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Space Colonization","description":"Organic looking life forms from math.","author":"John King","date":"5/8/2022","categories":["R","ggplot2","generative art"],"image":"teaser.png","code-copy":true},"extensions":{"book":{"multiFile":true}}}}}