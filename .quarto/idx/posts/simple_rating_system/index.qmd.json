{"title":"Simple Rating System","markdown":{"yaml":{"title":"Simple Rating System","description":"How football simple rating systems work. One sentence at a time.","author":"John King","date":"2/14/2022","format":{"html":{"toc":true,"code-fold":false,"code-tools":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"message":false,"echo":true},"categories":["R","ggplot2","college football","sports analytics"],"image":"teaser.png"},"headingText":"Motivation","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\nIn my [last post](https://jfking.netlify/posts/oregon-football/), I was playing around with data from an API offered by <http://collegefootballdata.com>.\n\nThen I found some blog posts on the site, and I thought a couple of them on how Simple Rating Systems work were interesting.\n\nIn particular, [this one](https://blog.collegefootballdata.com/talking-tech-bu/).\n\nThey did all their coding in Python, but I'm becoming more and more of an R fan, so I thought I'd re-code the wheel, so to speak.\n\nIn their post, they used data from the 2019 season, so for consistency, I'll do the same.\n\nAlso, in the last post, I was using `tidyr` to un-nest JSON data.\n\nIt seemed add to me that you have to do these repeated `unnest_auto()` steps to get things parsed out.\n\nIf it's automatic, why do I have to keep doing it manually?\n\nAfter some more Googling, I found the [tidyjson](https://github.com/colearendt/tidyjson) package, which has a nice `spread_all` function that I'll use instead.\n\n## Simple Rating System: The Math\n\nThis, to me, is the coolest part.\n\nI had no idea this is how some rating systems work, and it's pretty slick.\n\nIt's just one big system of equations that you solve with regular 'ol linear algebra.\n\nIn other words, solve $Ax=b$.\n\nThat's it.\n\nI'll start with the $b$ vector - that's easiest to explain.\n\n### The b Vector\n\nThe $b$ vector is each team's average margin of victory for the season.\n\nCouldn't be any simpler.\n\n### The A Matrix\n\nThis is a little more complicated.\n\nThe $A$ matrix will have dimensions of 130x130 - one row and column for each FBS team.\n\nThe diagonal will be 1's (i.e., the identity matrix).\n\nThink of the rest of the matrix in terms of rows.\n\nWe'll set it up alphabetically, so the first row will be for Air Force.\n\nFirst, we'll count how many games Air Force played that season.\n\nThen we'll identify all of Air Force's opponents - those are the columns.\n\nAs I said, the Air Force-Air Force entry will have a 1.\n\nMoving across the columns, if Air Force *didn't* play that team, put a 0 there.\n\nIf they *did*, divide the number of times Air Force played that team by the total number of games played and put that value in the column.\n\nKeep doing that until you get to the last column (i.e., that last potential match-up).\n\nThen repeat that process for the next team, Akron, and then the next, etc.\n\nThat's it.\n\nThis matrix represents each team's strength of schedule.\n\nPretty clever, right?\n\nA teams rating is it's mean margin of victory adjusted by it's strength of schedule.\n\n## The Code\n\nFirst we need to get all the FBS team names so we can exclude non-FBS games.\n\n```{r}\nlibrary(tidyjson)\nlibrary(dplyr)\nlibrary(httr)\nfbs <-\n  httr::GET(\n    url = \"https://api.collegefootballdata.com/teams/fbs?year=2019\",\n    httr::add_headers(\n      Authorization = paste(\"Bearer\", Sys.getenv(\"CFDB_API_TOKEN\"))\n    )\n  )\n\nfbs_teams <- \n  httr::content(fbs, \"parsed\") %>% # convert response to a nested list\n  spread_all %>% # rectangularize nested list into a dataframe\n  arrange(school) # make sure teams are in alphabetical order\n```\n\nNow we'll get team win-loss records.\n\n```{r}\nrecords <- \n  httr::GET(\n  url = \"https://api.collegefootballdata.com/games?year=2019\",\n  httr::add_headers(\n    accept = \"application/json\",\n    Authorization = paste(\"Bearer\", Sys.getenv(\"CFDB_API_TOKEN\"))\n  )\n)\n\nteam_records <- \n  httr::content(records, \"parsed\")\n\nteam_records <- tibble(data=team_records)\n\nteam_records <- \n  team_records %>% \n  tidyr::unnest_auto(data)\n```\n\nNow get scores and margin of victory for each game and eliminate non-FBS games.\n\nEventually we'll use this for the $b$ vector, but first we'll need it in this format for the $A$ matrix.\n\n```{r}\nscores <- team_records %>% \n  filter(home_team %in% (fbs_teams %>% .$school) & \n           away_team %in% (fbs_teams %>% .$school)) %>%\n  select(home_team, away_team, home_points, away_points) %>%\n  mutate(home_mov = home_points - away_points)\nhead(scores)\n```\n\nOk, now we can start to generate the $A$ matrix.\n\nFirst, I'll populate it with the number of times each team faced each other.\n\nThere's probably a more elegant way, but this is what came to me first.\n\n```{r}\nA <- data.frame(diag(0, nrow=130, ncol=130), \n                row.names = fbs_teams %>% .$school)\ncolnames(A) <- fbs_teams %>% .$school\n\n# populate dataframe with \nfor (r in 1:nrow(scores)){\n  home <- scores[r, 1] %>% .$home_team\n  away <- scores[r, 2] %>% .$away_team\n  A[home, away] <- A[home, away] + 1\n  A[away, home] <- A[away, home] + 1\n}\n\n# clean up\nrm(away, home, r)\n\nA[1:6, 1:6]\n```\n\nHold that thought on the $A$ matrix - we need a little more work to proceed.\n\nNext, rearrange the `scores` data to get one margin of victory score for each team and each game.\n\n```{r}\nmov <- scores %>% \n  select(home_team, home_mov) %>% \n  rename(team = home_team, mov = home_mov) %>% \n  bind_rows(scores %>% \n              select(away_team, home_mov) %>% \n              rename(team = away_team, mov = home_mov) %>% \n              mutate(mov = -mov))\n```\n\nNow count the total number of games each team played.\n\n```{r}\nn_games <- mov %>% count(team) %>% .$n\n```\n\nMultiply $A$'s columns by $1 / n_games$.\n\n`MARGIN=1` specifies to sweep across columns.\n\n```{r}\nA <- sweep(A, 1/n_games, MARGIN=1, FUN =`*`)\n```\n\nFinally, add the identity matrix and $A$ is built.\n\n```{r}\nA <- A + diag(1, nrow=130, ncol=130)\nA[1:6, 1:6]\n```\n\nNow calculate the mean margin of victory for each team.\n\nThis is the $b$ vector for the system of equations.\n\n```{r}\nb <- \n  mov %>%\n  group_by(team) %>% \n  summarize(mean_mov = mean(mov)) %>%\n  .$mean_mov\n```\n\nIt took a while to build the system of equations, but solving it is a one-liner.\n\n```{r}\nsolve(A, b)\n```\n\nIf you're familiar with linear models in R, this bit of code does the same thing.\n\nDon't forget to include a -1 to drop the intercept term.\n\n```{r}\nlm_A <- cbind(A, b)\ncoefficients(lm(b ~ . -1 , data=lm_A))\n```\n\nTo visualize the ratings, let's make a plot of the top 25.\n\n```{r}\nlibrary(ggplot2)\nlibrary(forcats)\n\nsrs <- \n  tibble(team = fbs_teams$school,\n         rating = solve(A, b),\n         color = fbs_teams$color)\n\ntop_25 <- \n  srs %>% \n  arrange(desc(rating)) %>% \n  slice(1:25)\n\nggplot() +\n  geom_col(data = top_25, \n           aes(x = fct_reorder(team, rating), y = rating), \n           fill = top_25$color) +\n  coord_flip() +\n  theme_bw() +\n  ylab(\"Rating\") +\n  xlab(\"Team\")\n```\n\nIn the College Football Data blog, they further refine the rating by factoring in home field advantage, conference strength, and things like that.\n\nThat's fine, but I just wanted to get the basic mechanics down.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Simple Rating System","description":"How football simple rating systems work. One sentence at a time.","author":"John King","date":"2/14/2022","categories":["R","ggplot2","college football","sports analytics"],"image":"teaser.png","code-copy":true},"extensions":{"book":{"multiFile":true}}}}}