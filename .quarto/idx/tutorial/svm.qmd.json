{"title":"Support Vector Machines","markdown":{"yaml":{"title":"Support Vector Machines","author":"John King","date":"5/30/2020","format":{"html":{"toc":true,"code-copy":true,"df-print":"paged"}},"execute":{"warning":false,"echo":true},"bibliography":"references.bib","link-citations":true},"headingText":"Support Vector Classification","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nlibrary(Cairo)\n\nknitr::opts_chunk$set(\n  echo = TRUE,\n  message=FALSE, \n  warning=FALSE,\n  dev.args = list(png = list(type = \"cairo\"))\n  )\n```\n\nSVR attempts to include as many data points as possible in the area between two lines. The following figure demonstrates this using dummy data with a linear relationship. The two parallel lines are the **margin**, and it's width is a hyperparameter $\\varepsilon$ that we can tune. If you draw a line through one of the points that fall outside the margin so that it is perpendicular to the margin, you have a **support vector**. A **cost** is applied to each point that falls outside the margin, and minimizing the cost determines the slope of the margin. Cost is another tunable hyperparameter, which is sometimes represented as $1/\\lambda$. Notice that unlike linear regression, if we were to add more points inside the margin, it would have no impact on the slope. SVR is also much less influence by outliers than linear regression. For the mathematical details behind SVR, refer to Section 12.3.6 in @hastie2008.\n\n```{r echo=FALSE}\nlibrary(tidyverse)\n\nset.seed(42)\n\ndf = tibble(\n  x = seq(0,10,length=100),\n  y = 1 + x + rnorm(100),\n  sv = case_when(y > 2 + x | y < x - 1 ~ 'out',\n                 y < 2 + x & y > x - 1 ~ 'in'))\n\nM = matrix(c(1, -1, 1, 1), ncol=2, byrow= TRUE)\na = c(2, rowSums(df %>% select(x,y))[12])\nxy = solve(M) %*% a\n\nggplot() +\n  annotate(\"segment\", x=df$x[12], xend=xy[2], y=df$y[12], yend = xy[1], color='blue') +\n  annotate(\"text\", x=1.5, y=7, label=\"Support\\nVector\", color='blue') +\n  geom_segment(aes(x=1.5, xend=1.5, y=6.2, yend=4.5), \n               color='blue', arrow=arrow(length = unit(0.1, \"inches\"))) +\n  geom_abline(slope=1, intercept=-1) +\n  geom_abline(slope=1, intercept=2) +\n  geom_point(data = df, aes(x, y, color=sv)) +\n  scale_color_manual(values = c('black', 'red')) +\n  ggtitle(\"Support Vector Regression\") +\n  xlab(\"x\") + ylab(\"y\") +\n  coord_fixed() +\n  theme_bw() +\n  theme(legend.position=\"none\")\n\n```\n\nChoosing values for the hyperparameters $\\varepsilon$ and $\\lambda$ is once again done through cross validation. To do this in *R*, we'll use some functions from the `e1071` package (another option is the `LiblineaR` package). Before we get to cross validation, let's just look at how to build an SVR model. The syntax is the same as for linear models, we just replace `lm()` with `svm()`. Note that the function is not `svr()` because the function can do both regression and classification. To make this more interesting, we'll switch back to the `airquality` data. From the model summary below, `SVM-type:  eps-regression` tells us that the function is performing regression and not classification, then we see the hyperparameter values and the number of support vectors used to fit the model.\n\nFor the kernel, we have four choices: linear, polynomial, radial basis, and sigmoid. Selecting a linear kernel will force a straight line fit, and the other three kernels are different methods for adding curvature to the regression line[^1]. The theory behind SVR kernels is beyond the scope of this tutorial, but if you want to dig deeper:\n\n[^1]: Changing the kernel to specify the type of fit is known as the kernel trick.\n\n-   Here are some slides titled [SVM dual, kernels and regression](http://www.robots.ox.ac.uk/~az/lectures/ml/lect3.pdf) from The University of Oxford.\n\n-   Here's [An Idiot's Guide to Support Vector Machines](http://web.mit.edu/6.034/wwwbob/svm-notes-long-08.pdf), a catchy title from MIT.\n\n-   Here's post titled [Support Vector Machine: Kernel Trick; Mercer's Theorem](https://towardsdatascience.com/understanding-support-vector-machine-part-2-kernel-trick-mercers-theorem-e1e6848c6c4d) at towardsdatascience.com.\n\nFor our purposes, we just need to know that the three non-linear kernels have `gamma` as a hyperparameter that controls curvature.\n\nTo force a straight regression line, specify `kernel='linear'`. Also, the `svm()` by default scales all variables in the data set to have a mean of zero and equal variance. Scaling the variables will improve the model's performance, but we'll turn that off in this example so we can directly compare the coefficients to those produced by `lm()`.\n\n```{r}\nlibrary(e1071)\n\naq = airquality %>% drop_na()\n\naq.svm = svm(Ozone ~ Solar.R, data=aq, kernel='linear', scale=FALSE)\nsummary(aq.svm)\n```\n\nWe can then extract the coefficients with `coef()`.\n\n```{r}\n(coeffs = coef(aq.svm))\n```\n\nUsing `lm()`, we get the following coefficients.\n\n```{r}\naq.lm = lm(Ozone ~ Solar.R, data=aq)\nsummary(aq.lm)\n```\n\nThe coefficients produced by the two models might seem fairly different. The following plot shows the data with the two regression lines for comparison. Notice how the linear model is more influenced by the extreme high ozone values (possible outliers).\n\n```{r}\nggplot() +\n  geom_point(data = aq, aes(x=Solar.R, y=Ozone)) +\n  geom_abline(slope=coeffs[2], intercept=coeffs[1], color='red') + \n  annotate(\"text\", x=315, y=50, label=\"svm()\", color='red') +\n  geom_abline(slope=aq.lm$coefficients[2], \n              intercept=aq.lm$coefficients[1], \n              color='blue') +\n  annotate(\"text\", x=315, y=70, label=\"lm()\", color='blue') +\n  theme_bw()\n\n```\n\nNow we'll re-fit the model with a non-linear regression line and invoking scaling. To extract the predicted response, we use the `predict()` function just like with linear models. Plotting the predicted response gives is the following.\n\n```{r}\naq.svm2 = svm(Ozone ~ Solar.R, data=aq)\n\naq = aq %>% mutate(svrY = predict(aq.svm2, data=aq))\n\nggplot(aq) +\n  geom_point(aes(Solar.R, Ozone), color='black') +\n  geom_line(aes(Solar.R, svrY), color='red') +\n  ggtitle(\"SVR With Default Hyperparameters\") +\n  coord_fixed() +\n  theme_bw()\n```\n\nTo tune the hyperparameters with cross validation, we can use the `tune` function from the `e1017` package. If we give the `tune` function a range of values for the hyperparameters, it will perform a grid search of those values. In the following example, we're therefore fitting 100 different models. If we print the object returned from `tune`, we see that it performed 10-fold cross validation, the best hyperparameter values, and the mean squared error of the best performing model.\n\n```{r}\nset.seed(42)\naq.tune = tune.svm(Ozone ~ Solar.R, \n                   data = aq, gamma=seq(0.1, 1, 0.1), \n                   cost = seq(1, 100, 10))\nprint(aq.tune)\n```\n\nWe can visualize the tune results as well by printing the `aq.tune` object. Here we see the range of cost and epsilon values with their associated mean squared error. The lower the error, the better, and those are indicated by the darkest blue regions.\n\n```{r}\nplot(aq.tune)\n```\n\nI prefer to choose a wide range of tuning parameter values initially, and then do a finer search in the area with the lowest error. It looks like we need a low gamma and a high cost.\n\n```{r}\nset.seed(42)\naq.tune = tune.svm(Ozone ~ Solar.R, \n                   data = aq, \n                   gamma=seq(0.02, 0.22, 0.05), \n                   cost = seq(80, 100, 2))\nprint(aq.tune)\n```\n\nThe best model from the tuning call can be obtained with `aq.tune$best.model`, and we can then apply the `predict` function to get the best fit regression.\n\n```{r}\naq$svrY = predict(aq.tune$best.model, data=aq)\n\nggplot(aq) +\n  geom_point(aes(Solar.R, Ozone), color='black') +\n  geom_line(aes(Solar.R, svrY), color='red') +\n  ggtitle(\"SVR With Tuned Hyperparameters\") +\n  coord_fixed() +\n  theme_bw()\n```\n\n\nClassification problems have either a binary or categorical response variable. To demonstrate how SVC works, we'll start with the `iris` data set, which contains four predictors and one categorical response variable. Plotting petal length versus petal width for the setosa and versicolor species shows that the two species are **linearly separable**, meaning we can draw a straight line on the plot that completely separates the two species. If we want to train an SVC to make predictions on new data, the question becomes: how do we draw the line that separates the data? There are infinitely many options, three of which are shown on the plot.\n\n```{r echo=FALSE}\nggplot(iris %>% filter(Species %in% c('setosa', 'versicolor')), \n       aes(x=Petal.Length, y=Petal.Width, color=Species)) +\n  geom_point() +\n  geom_abline(slope=1.2, intercept=-2.2, color='blue', linetype=2, size=1) +\n  geom_abline(slope=0, intercept=0.8, color='red', linetype=3, size=1) +\n  geom_abline(slope=-1, intercept=3.1, color='green', linetype=4, size=1) +\n  theme_bw()\n```\n\nSupport vector classification uses margins, but in a different way than SVR, to find a line that separates the data. If you think of the two parallel margin lines as a street, the idea is that we want to fit the widest possible street between the species because doing so results in the rest of the data points being as far off the street as possible. The two points below that fall on the margin determine the location of the support vectors.\n\n```{r echo=FALSE}\nggplot(iris %>% filter(Species %in% c('setosa', 'versicolor')), \n       aes(x=Petal.Length, y=Petal.Width, color=Species)) +\n  geom_abline(slope=-1, intercept=3.2, color='black', linetype=1, size=1) +\n  geom_abline(slope=-1, intercept=2.3, color='black', linetype=2, size=1) +\n  geom_abline(slope=-1, intercept=4.1, color='black', linetype=2, size=1) +\n  geom_point(size=2) +\n  theme_bw()\n```\n\nWhat happens when two categories aren't linearly separable, as is the case when we look at versicolor and virginica below?\n\n```{r echo=FALSE}\niris_vv = droplevels(iris %>% filter(Species %in% c('versicolor', 'virginica')))\n\nggplot(iris_vv, aes(x=Petal.Length, y=Petal.Width, color=Species)) +\n  geom_point() +\n  theme_bw()\n```\n\nWe still want to draw two parallel lines through the data sets, but the only way to do it is to have some observations in the middle of the street, or even on the wrong side of the line (called **margin violations**). We still want to fit as wide of a street as possible through the data points, but now we must also limit the number of margin violations. As with SVR, we can assign a **cost** for each margin violation. Since margin violations are generally bad, we might be tempted to apply a large cost; however, we must also consider how well the model will generalize. Below are the linear boundaries for two choices of cost. Support vectors are based on the points surrounded by black.\n\n```{r echo=FALSE, fig.width=8, message=FALSE, warning=FALSE}\niris.svm = svm(Species~ Petal.Length + Petal.Width, \n               kernel='linear', cost=1, scale=FALSE, data = iris_vv)\n\nw = t(iris.svm$coefs) %*% iris.svm$SV # weight vector\nslope = -w[1]/w[2]\nintercept = iris.svm$rho/w[2]\n\ndf_sv = iris_vv[iris.svm$index, ] # get the support vectors\n\np1 = ggplot(iris_vv, aes(x=Petal.Length, y=Petal.Width, color=Species)) +\n  geom_point(data=df_sv, \n             aes(x=Petal.Length, y=Petal.Width), \n             color='black', size = 5, alpha=0.5) +\n  geom_abline(slope=slope, \n              intercept=intercept, color='black', linetype=1, size=1) +\n  geom_abline(slope=slope, \n              intercept=intercept+1/w[2], color='black', linetype=2, size=1) +\n  geom_abline(slope=slope, \n              intercept=intercept-1/w[2], color='black', linetype=2, size=1) +\n  geom_point() +\n  theme_bw()\n\niris.svm2 = svm(Species~ Petal.Length + Petal.Width, \n                kernel='linear', cost=100, scale=FALSE,\n                data = iris_vv)\n\nw2 = t(iris.svm2$coefs) %*% iris.svm2$SV # weight vector\nslope2 = -w2[1]/w2[2]\nintercept2 = iris.svm2$rho/w2[2]\n\ndf_sv2 = iris_vv[iris.svm2$index, ] # get the support vectors\n\np2 = ggplot(iris_vv, aes(x=Petal.Length, y=Petal.Width, color=Species)) +\n  geom_point(data=df_sv2, \n             aes(x=Petal.Length, y=Petal.Width), \n             color='black', size = 5, alpha=0.5) +\n  geom_abline(slope=slope2, \n              intercept=intercept2, color='black', linetype=1, size=1) +\n  geom_abline(slope=slope2, \n              intercept=intercept2+1/w2[2], color='black', linetype=2, size=1) +\n  geom_abline(slope=slope2, \n              intercept=intercept2-1/w2[2], color='black', linetype=2, size=1) +\n  geom_point() +\n  theme_bw()\n\nGGally::ggmatrix(list(p1, p2), nrow=1, ncol=2, \n                 xAxisLabels = c(\"Cost = 1\", \"Cost = 100\"), \n                 legend=c(1,1))\n```\n\nInterestingly, the margins (and therefore the decision boundary) don't have to be straight lines. SVC also accommodates a curved boundary as in the example below. With a polynomial kernel, the curvature is controlled by the degree of the polynomial. In the plot, note that the support vectors are the `X` points.\n\n```{r echo=FALSE}\niris.svm3 = svm(Species~ Petal.Length + Petal.Width, \n                kernel='polynomial', degree=4, cost=1, scale=FALSE,\n                data = iris_vv)\nplot(iris.svm3, Petal.Width ~ Petal.Length, data=iris_vv)\n```\n\n#### Example In *R*\n\nIn this section, we'll walk through an example using the full `iris` data set. First, we'll split the data set into a training set that includes 80% of the data, and a test set with the remaining 20% using the `caTools` package.\n\n```{r}\nset.seed(0)\ntrain = caTools::sample.split(iris, SplitRatio = 0.8)\niris_train = subset(iris, train == TRUE)\niris_test = subset(iris, train == FALSE)\n```\n\nNext, we'll tune two models using a linear kernel and a radial basis function (which allows for curvature). We'll tune both models over a range of gamma and cost values.\n\n```{r}\niris.lin = tune.svm(Species~., data=iris_train, \n                    kernel=\"linear\", \n                    gamma = seq(0.1, 1, 0.1), \n                    cost = seq(1, 100, 10))\n\niris.rbf = tune.svm(Species~., data=iris_train, \n                    kernel=\"radial\", \n                    gamma = seq(0.1, 1, 0.1), \n                    cost = seq(1, 100, 10))\n\niris.lin$best.model\niris.rbf$best.model\n```\n\nBoth models are using a low cost, but the radial basis function model has twice as many support vectors. To compare model performance, we'll make predictions using the test set and display each model's **confusion matrix** using the `cvms` package (note: we could also create a simple confusion matrix with `table(iris_test[, 5], predictions)`).\n\n```{r message=FALSE, warning=FALSE}\n# get the confusion matrix for the linear kernel\nlin_conf_mat = cvms::confusion_matrix(\n  targets = iris_test[, 5], \n  predictions = predict(iris.lin$best.model, type = 'response', newdata = iris_test[-5]))\n\n# get the confusion matrix for the radial kernel\nrbf_conf_mat = cvms::confusion_matrix(\n  targets = iris_test[, 5],\n  predictions = predict(iris.rbf$best.model, type = 'response', newdata = iris_test[-5]))\n\n# plot the confusion matrix for the linear kernel (it's a ggplot2 object!)\ncvms::plot_confusion_matrix(lin_conf_mat$`Confusion Matrix`[[1]]) + \n  ggtitle(\"Linear Kernel\")\n```\n\nThe SVC model with the linear kernel did a great job! Of the 30 observations in the test set, only two were incorrectly classified. If this is the first time you've seen a confusion matrix, then what you see are the target (or actual) species by column and the species predictions from the SVC by row. In each cell, we see the percent and count of the total observations that fell into that cell. From this plot, we can identify true positives, false positives, etc. using the following guide.\n\n|                  |     |                |                |\n|------------------|-----|----------------|----------------|\n| Confusion Matrix |     | Target         |                |\n|                  |     | Yes            | No             |\n| Prediction       | Yes | True Positive  | False Positive |\n|                  | No  | False Negative | True Positive  |\n\nA perfect classifier will have zeros everywhere in the table except the diagonal. In our case, it's close to perfect. We just have two false negatives because two flowers that were actually virginica, were predicted to be versicolor. Now let's look at the radial kernel results.\n\n```{r message=FALSE, warning=FALSE}\ncvms::plot_confusion_matrix(rbf_conf_mat$`Confusion Matrix`[[1]]) + \n  ggtitle(\"Radial Kernel\")\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"svm.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","editor":"visual","theme":{"dark":"darkly","light":"flatly"},"title":"Support Vector Machines","author":"John King","date":"5/30/2020","bibliography":["references.bib"],"link-citations":true,"code-copy":true},"extensions":{"book":{"multiFile":true}}}}}